{"version":3,"sources":["meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/core/global.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/core/config.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/core/utils.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/core/events.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/core/event.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/core/event_manager.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/core/base_class.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/core/schema.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/core/classes.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/storage/init_class.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/storage/init_definition.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/behaviors/global.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/behaviors/behavior.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/behaviors/class_behavior.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/behaviors/create_behavior.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/behaviors/init_class.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/behaviors/init_definition.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/events/init_class.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/events/init_definition.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/ejson/init_module.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/methods/init_class.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/methods/init_definition.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/fields/global.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/fields/create_type.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/fields/base_field.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/fields/types/null_field.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/fields/types/string_field.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/fields/types/number_field.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/fields/types/boolean_field.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/fields/types/date_field.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/fields/types/object_field.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/fields/types/array_field.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/fields/utils.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/fields/modifiers.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/fields/set_default.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/fields/set.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/fields/get.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/fields/raw.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/fields/push.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/fields/pop.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/fields/pull.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/fields/inc.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/fields/modified.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/fields/ejson.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/fields/init_class.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/fields/init_definition.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/indexes/init_class.js","meteor://ðŸ’»app/packages/jagi_astronomy/lib/modules/indexes/init_definition.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClBA;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC/RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACnUA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzCA;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC9OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC3KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC3MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC/LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/packages/jagi_astronomy.js","sourcesContent":["Astronomy = {};\nAstro = Astronomy;\nAstro.classes = {};\n","Astro.config = {\n  verbose: true,\n  disableTransform: false,\n  triggerEvents: true\n};\n","Astro.utils = {};\n\nAstro.utils.warn = function(warning) {\n  if (console && console.warn && Astro.config.verbose) {\n    console.warn(warning);\n  }\n};\n\nAstro.utils.string = {};\n\nAstro.utils.string.ucfirst = function(str) {\n  return str.charAt(0).toUpperCase() + str.substr(1);\n};\n\nAstro.utils.object = {};\n\nAstro.utils.object.deepMerge = function(target, source, key) {\n  var self = this;\n\n  var mergeKey = function(key) {\n    var targetValue = target[key];\n    var sourceValue = source[key];\n\n    if (_.has(target, key)) {\n      result[key] = self.deepMerge(targetValue, sourceValue, key);\n    } else {\n      if (\n        _.isObject(sourceValue) &&\n        !_.isArray(sourceValue) &&\n        !_.isFunction(sourceValue)\n      ) {\n        result[key] = self.deepMerge({}, sourceValue, key);\n      } else {\n        result[key] = sourceValue;\n      }\n    }\n  };\n\n  if (_.isArray(source) && _.isArray(target)) {\n    return [].concat(target, source);\n  } else if (_.isObject(target) && _.isObject(source)) {\n    var result = _.extend({}, target);\n    _.each(_.keys(source), mergeKey);\n    return result;\n  } else {\n    return source;\n  }\n};\n\nAstro.utils.class = {};\n\nAstro.utils.class.transformToClass = function(className) {\n  return function(attrs) {\n    if (Astro.config.disableTransform) {\n      return attrs;\n    }\n\n    var Class = Astro.getClass(className);\n\n    if (Class) {\n      var typeField = Class.getTypeField();\n      if (typeField) {\n        var TypeClass = Astro.getClass(attrs[typeField]);\n        if (TypeClass) {\n          Class = TypeClass;\n        }\n      }\n\n      var doc = new Class(attrs);\n      doc._isNew = false;\n      return doc;\n    }\n\n    return attrs;\n  };\n};\n\nAstro.utils.class.inherits = function(Child, Parent) {\n  Child.prototype = Object.create(Parent.prototype);\n  Child.prototype.constructor = Child;\n};\n","Astro.Events = function() {};\n\n_.extend(Astro.Events.prototype, {\n  on: function(eventName, eventHandler) {\n    this._events = this._events || {};\n    eventName = eventName.toLowerCase();\n\n    this._events[eventName] = this._events[eventName] || [];\n\n    // Add event only if it's not already on the events list.\n    if (!_.contains(this._events[eventName], eventHandler)) {\n      this._events[eventName].push(eventHandler);\n    }\n  },\n\n  off: function(eventName, eventHandler) {\n    this._events = this._events || {};\n    eventName = eventName.toLowerCase();\n\n    if (arguments.length === 1) {\n      // Remove all event handlers for given event name.\n      delete this._events[eventName];\n    } else if (arguments.length === 2) {\n      // Remove only one event handler (the passed one) from the events list.\n      var index = _.indexOf(this._events[eventName], eventHandler);\n      if (index >= 0) {\n        this._events[eventName].splice(index, 1);\n      }\n    }\n  },\n\n  has: function(eventName, eventHandler) {\n    this._events = this._events || {};\n    eventName = eventName.toLowerCase();\n\n    if (arguments.length === 1) {\n      return _.has(this._events, eventName);\n    } else if (arguments.length === 2) {\n      return _.has(this._events, eventName) &&\n        _.contains(this._events[eventName], eventHandler);\n    }\n  },\n\n  emit: function(event) {\n    this._events = this._events || {};\n    var eventName = event.type;\n    var target = event.target;\n    eventName = eventName.toLowerCase();\n\n    return _.every(this._events[eventName], function(eventHandler) {\n      if (target) {\n        eventHandler.call(target, event);\n      } else {\n        eventHandler(event);\n      }\n      return !event.stopped;\n    });\n  },\n\n  each: function(eventName, callback, target) {\n    this._events = this._events || {};\n    eventName = eventName.toLowerCase();\n\n    _.each(this._events[eventName], function(eventHandler) {\n      if (target) {\n        callback.call(target, eventHandler);\n      } else {\n        callback(eventHandler);\n      }\n    });\n  },\n\n  every: function(eventName, callback, target) {\n    this._events = this._events || {};\n    eventName = eventName.toLowerCase();\n\n    _.every(this._events[eventName], function(eventHandler) {\n      if (target) {\n        return callback.call(target, eventHandler);\n      } else {\n        return callback(eventHandler);\n      }\n    });\n  }\n});\n\nAstro.Events.mixin = function(obj) {\n  if (_.isFunction(obj)) {\n    _.each(Astro.Events.prototype, function(method, methodName) {\n      obj.prototype[methodName] = method;\n    });\n  } else {\n    _.each(Astro.Events.prototype, function(method, methodName) {\n      obj[methodName] = method;\n    });\n  }\n  return obj;\n};\n","Astro.Event = function(type, data) {\n  this.type = type.toLowerCase();\n  this.data = data;\n};\n\n_.extend(Astro.Event.prototype, {\n  type: null,\n  data: null,\n  stopped: false,\n  defaultPrevented: false,\n\n  stopPropagation: function() {\n    this.stopped = true;\n  },\n\n  preventDefault: function() {\n    this.defaultPrevented = true;\n  }\n});\n","Astro.eventManager = Astro.Events.mixin({});\n","var BaseClass = Astro.BaseClass = function BaseClass(attrs) {\n  var doc = this;\n  var Class = doc.constructor;\n  attrs = attrs || {};\n\n  // Add the private \"_modifiers\" property to track changes made on the document.\n  doc._modifiers = {};\n\n  // Trigger the \"beforeInit\" event handlers.\n  event = new Astro.Event('beforeInit', attrs);\n  event.target = doc;\n  Class.emitEvent(event);\n  // If an event was prevented from the execution, then we stop here.\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  var fieldsNames = Class.getFieldsNames();\n  _.each(fieldsNames, function(fieldName) {\n    var fieldValue = attrs[fieldName];\n    if (_.isUndefined(fieldValue)) {\n      // Set a default value.\n      doc._setDefault(fieldName);\n    } else {\n      // Set a value.\n      doc._setOne(fieldName, fieldValue, {\n        cast: true,\n        modifier: false,\n        mutable: true\n      });\n    }\n  });\n\n  // Set the \"_isNew\" flag indicating if an object had been persisted in the\n  // collection.\n  doc._isNew = true;\n\n  // Trigger the \"afterInit\" event handlers.\n  event = new Astro.Event('afterInit', attrs);\n  event.target = doc;\n  Class.emitEvent(event);\n};\n\n// Add the \"_original\" property for backward compatibility that will be lazy\n// executed.\nObject.defineProperty(BaseClass.prototype, '_original', {\n  get: function() {\n    var doc = this;\n    var Class = doc.constructor;\n\n    if (doc._id) {\n      var originalDoc = Class.findOne(doc._id);\n    } else {\n      var originalDoc = new Class();\n    }\n\n    var _original = {};\n    var fieldsNames = Class.getFieldsNames();\n    _.each(fieldsNames, function(fieldName) {\n      _original[fieldName] = originalDoc[fieldName];\n    });\n\n    return _original;\n  },\n  enumerable: false,\n  configurable: false\n});\n","var checkSchemaDefinition = function(schemaDefinition) {\n  // The schema definition has to be an object.\n  if (!Match.test(schemaDefinition, Object)) {\n    throw new Error('The class definition has to be an object');\n  }\n  // The class name has to be a string.\n  if (!Match.test(schemaDefinition.name, String)) {\n    throw new Error('The \"name\" property has to be a string');\n  }\n};\n\nAstro.Schema = function Schema(schemaDefinition) {\n  var schema = this;\n\n  checkSchemaDefinition.call(schema, schemaDefinition);\n\n  // Store the schema definition.\n  schema.definitions = [];\n\n  // Store class name.\n  if (_.has(schemaDefinition, 'name')) {\n    schema.className = schemaDefinition.name;\n  }\n\n  // Store parent class name.\n  if (_.has(schemaDefinition, 'inherit')) {\n    schema.parentClassName = schemaDefinition.inherit;\n  }\n};\n","Astro.getClass = function(className) {\n  return Astro.classes[className];\n};\n\nvar methods = {\n  getName: function() {\n    return this.schema.className;\n  },\n\n  getParent: function() {\n    return Astro.getClass(this.schema.parentClassName);\n  },\n\n  inherit: function(schemaDefinition) {\n    var ParentClass = this;\n\n    schemaDefinition.inherit = ParentClass.getName();\n\n    return Astro.Class(schemaDefinition);\n  },\n\n  extend: function(schemaDefinition) {\n    var Class = this;\n    var schema = Class.schema;\n\n    Astro.eventManager.each('initDefinition', function(eventHandler) {\n      eventHandler.call(Class, schemaDefinition);\n    });\n    // Store the schema definition.\n    schema.definitions.push(schemaDefinition);\n\n    // Setup schema with the schema definition.\n    Astro.eventManager.each('initSchema', function(eventHandler) {\n      eventHandler.call(schema, schemaDefinition);\n    });\n  }\n};\n\nAstro.createClass = Astro.Class = function(schemaDefinition) {\n  var Class = function Class() {\n    if (!(this instanceof Class)) {\n      throw new Error('Use the \"new\" keyword to create an instance');\n    }\n\n    var doc = this;\n    var args = arguments;\n\n    // Call default constructor.\n    Astro.BaseClass.apply(doc, args);\n  };\n\n  // Extend class object with some helper methods.\n  _.extend(Class, methods);\n\n  // Initialize a schema and store it in the class object.\n  Class.schema = new Astro.Schema(schemaDefinition);\n\n  // Add given class to list of all defined classes.\n  Astro.classes[Class.getName()] = Class;\n\n  // Extend base class.\n  var ParentClass = Class.getParent();\n  // Extend another model class if provided.\n  if (ParentClass) {\n    Astro.utils.class.inherits(Class, ParentClass);\n  } else {\n    Astro.utils.class.inherits(Class, Astro.BaseClass);\n  }\n\n  // Setup class using the \"initClass\" event handlers.\n  Astro.eventManager.each('initClass', function(eventHandler) {\n    eventHandler.call(Class);\n  });\n\n  if (ParentClass) {\n    _.each(ParentClass.schema.definitions, function(schemaDefinition) {\n      Class.extend(schemaDefinition);\n    });\n  }\n  Class.extend(schemaDefinition);\n\n  return Class;\n};\n","var classMethods = {};\n\nvar checkSelector = function(selector, methodName) {\n  // If we are not on the server and we are trying to perform non insert\n  // operation on a document then it has to be done by ID.\n  if (\n    !Meteor.isServer && !LocalCollection._selectorIsIdPerhapsAsObject(selector)\n  ) {\n    throw new Meteor.Error(\n      403,\n      'Not permitted. Untrusted code may only ' + methodName +\n      ' documents by ID.'\n    );\n  }\n};\n\nclassMethods.getCollection = function() {\n  return this.schema.collection;\n};\n\nclassMethods.getTypeField = function() {\n  return this.schema.typeField;\n};\n\n/**\n * @summary Inserts a document into the collection.\n * @locus Anywhere\n * @method insert\n * @memberOf Astro.BaseClass\n * @class\n * @param {Object} [doc] A doc to insert.\n * @param {Function} [callback] Optional. If present, called with an error object as the first argument and, if no error, the _id as the second.\n * @returns {String} Returns an _id of an inserted document.\n */\nclassMethods.insert = function(doc, callback) {\n  var Class = this;\n\n  try {\n    var doc = new Class(doc);\n    var id = doc.save();\n    // Execute a callback function if provided.\n    if (_.isFunction(callback)) {\n      callback(undefined, id);\n      return id;\n    }\n    // Return result.\n    return id;\n  } catch (e) {\n    if (e instanceof Meteor.Error && _.isFunction(callback)) {\n      // Execute a callback function with an error.\n      callback(e);\n    } else {\n      // Throw the error again, if we can not handle it.\n      throw e;\n    }\n  }\n};\n\n/**\n * @summary Updates documents in the collection.\n * @return\n * @locus Anywhere\n * @method update\n * @memberOf Astro.BaseClass\n * @class\n * @param {MongoSelector} selector Specifies which documents to modify\n * @param {MongoModifier} modifier Specifies how to modify the documents\n * @param {Object} [options]\n * @param {Boolean} options.multi True to modify all matching documents; false to only modify one of the matching documents (the default).\n * @param {Boolean} options.upsert True to insert a document if no matching documents are found.\n * @param {Function} [callback] Optional. If present, called with an error object as the first argument and, if no error, the number of affected documents as the second.\n * @returns {String|Number} Returns an inserted document ID or number of document that have been updated.\n */\nclassMethods.update = function(selector, modifier, options, callback) {\n  var Class = this;\n  var Collection = Class.getCollection();\n\n  // The options argument is optional and if there are only three arguments,\n  // then it may mean that the last argument is a callback function.\n  if (arguments.length === 3 && _.isFunction(options)) {\n    callback = options;\n    options = {};\n  }\n  // Make sure that options object is created.\n  options = options || {};\n  // Check validity of selector.\n  if (Collection._name) {\n    checkSelector(selector, 'update');\n  }\n\n  try {\n    // We select one or many documents depending on the \"multi\" flag.\n    var docs;\n    if (options.multi) {\n      docs = Collection.find(selector);\n    } else {\n      docs = Collection.find(selector, {\n        limit: 1,\n      });\n    }\n\n    // INSERT.\n    if (docs.count() === 0 && options.upsert) {\n\n      // If there are no matching documents and the \"upsert\" option was set,\n      // then we have to insert a new document.\n      var doc = new Class();\n      // If a selector is ID, then set it on a document.\n      if (_.isString(selector)) {\n        doc.set('_id', selector);\n      // If selector is object, then set all fields from the selector on a\n      // document.\n      } else if (_.isObject(selector)) {\n        doc.set(selector);\n      }\n      // Execute a modifier on the document.\n      doc._executeModifier(modifier);\n      // Insert a document.\n      doc.save();\n      // Execute a callback function if provided.\n      if (_.isFunction(callback)) {\n        callback(undefined, doc._id);\n      }\n      // Return result.\n      return doc._id;\n\n    // UPDATE.\n    } else {\n\n      // Execute a modifier on each document.\n      var count = 0;\n      docs.forEach(function(doc, i) {\n        // Execute a modifier on the document.\n        doc._executeModifier(modifier);\n        // Run the \"forEach\" function if exists, i.\n        if (_.isFunction(options.forEach) && !options.forEach(doc, i)) {\n          return;\n        }\n        // Update a document.\n        count += doc.save();\n      });\n      // Execute a callback function if provided.\n      if (_.isFunction(callback)) {\n        callback(undefined, count);\n      }\n      // Return result.\n      return count;\n\n    }\n  } catch (e) {\n    if (e instanceof Meteor.Error && _.isFunction(callback)) {\n      // Execute a callback function with an error.\n      callback(e);\n    } else {\n      // Throw the error again, if we can not handle it.\n      throw e;\n    }\n  }\n};\n\n/**\n * @summary Modify one or more documents in the collection, or insert one if no matching documents were found.\n * @locus Anywhere\n * @method upsert\n * @memberOf Astro.BaseClass\n * @class\n * @param {MongoSelector} selector Specifies which documents to modify\n * @param {MongoModifier} modifier Specifies how to modify the documents\n * @param {Object} [options]\n * @param {Boolean} options.multi True to modify all matching documents; false to only modify one of the matching documents (the default).\n * @param {Function} [callback] Optional. If present, called with an error object as the first argument and, if no error, the number of affected documents as the second.\n * @returns {String|Number} Returns an inserted document ID or number of document that have been updated.\n */\nclassMethods.upsert = function(selector, modifier, options, callback) {\n  var Class = this;\n\n  return Class.update(\n    selector,\n    modifier,\n    _.extend({}, options, {upsert: true}),\n    callback\n  );\n};\n\n/**\n * @summary Remove documents from the collection\n * @locus Anywhere\n * @method remove\n * @memberOf Astro.BaseClass\n * @class\n * @param {MongoSelector} selector Specifies which documents to remove\n * @param {Function} [callback] Optional. If present, called with an error object as its argument.\n * @returns {Number} Returns number of removed documents.\n */\nclassMethods.remove = function(selector, callback) {\n  var Class = this;\n  var Collection = Class.getCollection();\n\n  // Check validity of selector.\n  if (Collection._name) {\n    checkSelector(selector, 'remove');\n  }\n\n  // Select all documents matching selector.\n  docs = Collection.find(selector);\n\n  // Try removing each document.\n  try {\n    var count = 0;\n    docs.forEach(function(doc, i) {\n      // Remove a document.\n      count += doc.remove();\n    });\n    // Execute a callback function if provided.\n    if (_.isFunction(callback)) {\n      callback(undefined, count);\n    }\n    // Return result.\n    return count;\n  } catch (e) {\n    if (e instanceof Meteor.Error && _.isFunction(callback)) {\n      // Execute a callback function with an error.\n      callback(e);\n    } else {\n      // Throw the error again, if we can not handle it.\n      throw e;\n    }\n  }\n};\n\n_.each(['find', 'findOne'], function(methodName) {\n  classMethods[methodName] = function(selector, options) {\n    var Class = this;\n    var schema = Class.schema;\n    var Collection = Class.getCollection();\n\n    if (_.isString(selector)) {\n      selector = {\n        _id: selector\n      };\n    }\n    selector = selector || {};\n    options = options || {};\n    options.transform = schema.transform ||\n      Astro.utils.class.transformToClass(Class.getName());\n\n    // Modify selector and options using the \"beforeFind\" event handlers.\n    var event = new Astro.Event('beforeFind', {\n      selector: selector,\n      options: options\n    });\n    event.target = Class;\n    Class.emitEvent(event);\n    // If a default operation was prevented, then we have to stop here.\n    if (event.defaultPrevented) {\n      return;\n    }\n\n    // If it's an inherited class, then get only documents being instances of\n    // the subclass.\n    var typeField = Class.getTypeField();\n    if (typeField) {\n      selector[typeField] = Class.getName();\n    }\n\n    var result = Collection[methodName](selector, options);\n\n    // Modify a query result using the \"afterFind\" event handlers.\n    var event = new Astro.Event('afterFind', {\n      selector: selector,\n      options: options,\n      result: result\n    });\n    event.target = Class;\n    Class.emitEvent(event);\n\n    return result;\n  };\n});\n\nAstro.eventManager.on(\n  'initClass', function onInitClassStorage(schemaDefinition) {\n    var Class = this;\n\n    // Add storage methods to the class.\n    _.extend(Class, classMethods);\n  }\n);\n","var prototypeMethods = {};\n\n/**\n * @summary Inserts or updates a document into the collection. Returns document _id on insert or modified documents count on update.\n * @locus Anywhere\n * @method save\n * @memberOf Astro.BaseClass\n * @instance\n * @param {Array} [fieldsNames] The list of fields that should only be saved into the collection.\n * @param {Function} [callback] Optional. If present, called with an error object as the first argument and, if no error, the _id or modified documents count as the second.\n */\nprototypeMethods.save = function(fieldsNames, callback) {\n  var doc = this;\n  var Class = doc.constructor;\n  var Collection = Class.getCollection();\n\n  // Handle arguments' types detection.\n  if (arguments.length === 1) {\n    if (_.isFunction(fieldsNames)) {\n      callback = fieldsNames;\n    }\n  }\n  if (_.isString(fieldsNames)) {\n    fieldsNames = [fieldsNames];\n  } else if (!_.isArray(fieldsNames)) {\n    fieldsNames = Class.getFieldsNames();\n  }\n\n  // Set the flag indicating whether we are updating or instering a document.\n  var inserting = doc._isNew;\n\n  // Trigger \"beforeSave\" event handlers.\n  var event = new Astro.Event('beforeSave');\n  event.target = doc;\n  Class.emitEvent(event);\n  // If user prevented default operation, then we have to stop here.\n  if (event.defaultPrevented) {\n    return inserting ? undefined : 0;\n  }\n  // Trigger \"beforeInsert\" or \"beforeUpdate\" event handlers.\n  event = new Astro.Event(inserting ? 'beforeInsert' : 'beforeUpdate');\n  event.target = doc;\n  Class.emitEvent(event);\n  // If user prevented default operation, then we have to stop here.\n  if (event.defaultPrevented) {\n    return inserting ? undefined : 0;\n  }\n\n  // Prepare a variable for storing a Mongo query result.\n  var result;\n\n  // Catch any error that may be cause by unability to save a document. It may\n  // be a Mongo exception for an index uniqueness etc. The returned error can be\n  // handled in the `saveError` event.\n  try {\n    if (inserting) {\n      // Inserting.\n\n      // Get plain values of all fields.\n      var values = doc._rawAll({\n        transient: false\n      });\n      // If, we are inserting a document with the null \"_id\", then we have to\n      // remove it.\n      if (_.isNull(values._id)) {\n        values = _.omit(values, '_id');\n      }\n      // Pick only these values that we want to save.\n      values = _.pick(values, fieldsNames);\n      // Insert a document.\n      result = doc._id = Collection.insert(values, callback);\n\n    } else {\n      // Updating.\n\n      // Get a modifier.\n      var modifier = doc._getModifiers();\n      // Get a document's id.\n      var id = doc._id;\n      // Update a document only if there is anything to update.\n      if (_.size(modifier) > 0) {\n        result = Collection.update(id, modifier, callback);\n      } else {\n        if (_.isFunction(callback)) {\n          callback(undefined, 0);\n        }\n        return 0;\n      }\n    }\n  } catch (e) {\n    if (e.name === 'MongoError') {\n      var event = new Astro.Event('saveError', {\n        error: e\n      });\n      event.target = doc;\n      Class.emitEvent(event);\n      if (event.defaultPrevented) {\n        return;\n      }\n    }\n\n    throw e;\n  }\n\n  // Change the \"_isNew\" flag to \"false\". Now a document is not new.\n  doc._isNew = false;\n\n  // Trigger \"afterInsert\" or \"afterUpdate\" event handlers.\n  var event = new Astro.Event(inserting ? 'afterInsert' : 'afterUpdate');\n  event.target = doc;\n  Class.emitEvent(event);\n  // Trigger \"afterSave\" event handlers.\n  var event = new Astro.Event('afterSave');\n  event.target = doc;\n  Class.emitEvent(event);\n\n  // Clear a modifier.\n  doc._clearModifiers();\n\n  // Return result of executing a Mongo query.\n  return result;\n};\n\n/**\n * @summary Removes a document from the collection. Returns an amount of removed documents.\n * @locus Anywhere\n * @method remove\n * @memberOf Astro.BaseClass\n * @instance\n * @param {Function} [callback] Optional. If present, called with an error object as the first argument and, if no error, the an amount of removed documents as the second.\n */\nprototypeMethods.remove = function(callback) {\n  var doc = this;\n  var Class = doc.constructor;\n  var Collection = Class.getCollection();\n\n  // Remove only when document has the \"_id\" field (it's persisted).\n  if (!doc._id) {\n    return 0;\n  }\n\n  // Trigger \"beforeRemove\" event handlers on the current and parent classes.\n  var event = new Astro.Event('beforeRemove');\n  event.target = doc;\n  Class.emitEvent(event);\n  // If user prevented default operation, then we have to stop here.\n  if (event.defaultPrevented) {\n    return 0;\n  }\n\n  // Remove document and save result.\n  var result = Collection.remove(doc._id, callback);\n\n  // Trigger \"afterRemove\" event handlers on the current and parent classes.\n  var event = new Astro.Event('afterRemove');\n  event.target = doc;\n  Class.emitEvent(event);\n\n  // Clear the \"_id\" attribute.\n  doc._id = null;\n\n  // Clear a modifier.\n  doc._clearModifiers();\n\n  // Set document as a new, so it will be possible to save document again.\n  doc._isNew = true;\n\n  // Return result of removing document.\n  return result;\n};\n\nprototypeMethods.reload = function() {\n  var doc = this;\n  var Class = doc.constructor;\n  var Collection = Class.getCollection();\n\n  // The document has to be already saved in the collection.\n  if (doc._id) {\n    // Get a document from the collection without the transformation.\n    var plainDoc = Collection.findOne(doc._id, {\n      transform: null,\n    });\n\n    // Init instance with the new values from the collection.\n    Astro.BaseClass.call(doc, plainDoc);\n\n    // Set the \"_isNew\" flag back to false.\n    doc._isNew = false;\n  }\n};\n\nprototypeMethods.copy = function(save) {\n  var doc = this;\n  save = save || false;\n\n  // Use EJSON to clone object.\n  var copy = EJSON.clone(doc);\n\n  // Remove the \"_id\" value and set the \"_isNew\" flag to false so that it will\n  // save the object as a new document instead updating the old one.\n  copy._id = null;\n  copy._isNew = true;\n\n  if (save) {\n    copy.save();\n  }\n\n  return copy;\n};\n\nvar events = {};\n\nevents.afterInit = function(attrs) {\n  var doc = this;\n  var Class = doc.constructor;\n\n  doc.set(Class.getTypeField(), Class.getName());\n};\n\nvar checkSchemaDefinition = function(schemaDefinition) {\n  var Class = this;\n\n  // The collection has to be an instance of the Mongo.Collection class.\n  if (_.has(schemaDefinition, 'collection') &&\n    !(schemaDefinition.collection instanceof Mongo.Collection)\n  ) {\n    throw new Error(\n      'The \"collection\" property has to be an instance of the ' +\n      '\"Mongo.Collection\" in the \"' + Class.getName() + '\" class'\n    );\n  }\n  // The \"typeField\" property has to be a string.\n  if (_.has(schemaDefinition, 'typeField') &&\n    !_.isString(schemaDefinition.typeField)\n  ) {\n    throw new Error(\n      'The \"typeField\" property has to be a string in the \"' +\n      Class.getName() + '\" class'\n    );\n  }\n};\n\nAstro.eventManager.on(\n  'initDefinition', function onInitDefinitionStorage(schemaDefinition) {\n    var Class = this;\n    var schema = Class.schema;\n\n    checkSchemaDefinition.call(Class, schemaDefinition);\n\n    // If there is no collection for the class, then we can stop class\n    // initialization for the module.\n    if (_.has(schemaDefinition, 'collection')) {\n      schema.collection = schemaDefinition.collection;\n    }\n\n    // If there is no collection related with a class, then we can not continue.\n    var Collection = Class.getCollection();\n    if (!Collection) {\n      return;\n    }\n\n    var transform = schemaDefinition.transform;\n    if (_.isUndefined(schema.transform) || _.isNull(transform)) {\n      if (_.isFunction(transform)) {\n        // Apply custom transformation function.\n        schema.transform = function(attrs) {\n          if (Astro.config.disableTransform) {\n            return attrs;\n          }\n          return transform(attrs);\n        };\n        Collection._transform = LocalCollection.wrapTransform(schema.transform);\n      } else if (_.isUndefined(transform)) {\n        // Apply standard transformation function, if the transform function was\n        // not provided and the collection does not have the transform function\n        // yet.\n        schema.transform = Astro.utils.class.transformToClass(Class.getName());\n        Collection._transform = LocalCollection.wrapTransform(\n          schema.transform\n        );\n      } else if (_.isNull(transform)) {\n        Collection._transform = schema.transform = null;\n      }\n    }\n\n    // We only add fields to the class if there is a collection provided in a\n    // class definition.\n    if (!_.has(schemaDefinition, 'collection')) {\n      return;\n    }\n\n    // Prepare an object for storing fields definitions and events list that\n    // will extend the current schema.\n    var extendDefinition = {\n      fields: {\n        // Add the \"_id\" field.\n        _id: {\n          type: 'null'\n        }\n      }\n    };\n\n    // Add the \"type\" field, to distinguish to what class we have to cast a\n    // document fetched from the collection.\n    var typeField = schemaDefinition.typeField;\n    if (typeField) {\n      schema.typeField = typeField;\n      extendDefinition.fields[typeField] = {\n        type: 'string'\n      };\n\n      // Add the \"afterInit\" event handler that sets a type field.\n      extendDefinition.events = {\n        afterInit: [events.afterInit]\n      };\n    }\n\n    // Extend the current schema definition.\n    Class.extend(extendDefinition);\n\n    // Add storage methods to the class prototype.\n    _.extend(Class.prototype, prototypeMethods);\n  }\n);\n","Astro.behaviors = {};\n\nAstro.getBehavior = function(behaviorName) {\n  return Astro.behaviors[behaviorName];\n};\n","var checkArguments = function(behaviorDefinition) {\n  // Check parameters validity.\n  if (!_.isObject(behaviorDefinition)) {\n    throw new Error('The behavior definition has to be an object');\n  }\n\n  // Check if behavior name is provided.\n  if (!_.has(behaviorDefinition, 'name')) {\n    throw new Error('The behavior name can not be empty');\n  }\n\n  // Check if behavior name is a string.\n  if (!_.isString(behaviorDefinition.name)) {\n    throw new Error('The behavior name has to be a string');\n  }\n\n  // Check if behavior with given name already exists.\n  if (_.has(Astro.behaviors, behaviorDefinition.name)) {\n    throw new Error(\n      'Behavior with the \"' + behaviorDefinition.name + '\" name already exists'\n    );\n  }\n};\n\nAstro.Behavior = function Behavior(behaviorDefinition) {\n  checkArguments.apply(this, arguments);\n\n  this.name = behaviorDefinition.name;\n  this.options = behaviorDefinition.options || {};\n  this.methods = behaviorDefinition.methods || {};\n  this.createSchemaDefinition = behaviorDefinition.createSchemaDefinition ||\n    function createSchemaDefinition() {\n      return {};\n    };\n};\n\nAstro.Behavior.prototype.createGenerator = function() {\n  var behavior = this;\n\n  return function classBehaviorGenerator(options) {\n    return new Astro.ClassBehavior({\n      behavior: behavior,\n      options: _.extend({}, behavior.options, options)\n    });\n  };\n};\n","Astro.ClassBehavior = function ClassBehavior(classBehaviorDefinition) {\n  this.behavior = classBehaviorDefinition.behavior;\n  this.options = classBehaviorDefinition.options;\n  this.definition = this.behavior.createSchemaDefinition(this.options);\n  _.extend(this, this.behavior.methods);\n};\n\nAstro.ClassBehavior.prototype.callMethod = function(methodName, doc) {\n  var method = this.behavior.methods[methodName];\n  if (!_.isFunction(method)) {\n    throw new Error(\n      'The \"' + methodName + '\" method in the \"' +\n      this.behavior.name + '\" behavior does not exist '\n    );\n  }\n\n  return method.call(doc);\n};\n","Astro.createBehavior = function(behaviorDefinition) {\n  var behavior = new Astro.Behavior(behaviorDefinition);\n  return Astro.behaviors[behavior.name] = behavior.createGenerator();\n};\n","var classMethods = {};\n\nclassMethods.hasBehavior = function(behaviorName) {\n  return _.has(this.schema.behaviors, behaviorName);\n};\n\nclassMethods.getBehavior = function(behaviorName) {\n  return this.schema.behaviors[behaviorName];\n};\n\nclassMethods.getBehaviors = function() {\n  return this.schema.behaviors;\n};\n\nAstro.eventManager.on(\n  'initClass', function onInitClassBehaviors() {\n    var Class = this;\n    var schema = Class.schema;\n\n    _.extend(Class, classMethods);\n\n    schema.behaviors = schema.behaviors || {};\n  }\n);\n","var checkBehaviorData = function(behaviorData, behaviorName, className) {\n  if (!Match.test(behaviorData, Match.OneOf(Object, null, undefined))) {\n    throw new Error(\n      'The behavior data in the \"' + className +\n      '\" class schema has to be an object or left empty'\n    );\n  }\n  if (!Match.test(behaviorName, String)) {\n    throw new Error(\n      'The behavior name in the \"' + className +\n      '\" class schema has to be a string'\n    );\n  }\n  if (!_.has(Astro.behaviors, behaviorName)) {\n    throw new Error(\n      'The \"' + behaviorName + '\" behavior in \"' + className +\n      '\" class schema does not exist'\n    );\n  }\n};\n\nAstro.eventManager.on(\n  'initDefinition', function onInitDefinitionBehaviors(schemaDefinition) {\n    var Class = this;\n    var schema = Class.schema;\n    var behaviorsDefinitions = {};\n\n    if (_.has(schemaDefinition, 'behaviors')) {\n      _.each(schemaDefinition.behaviors, function(behaviorData, behaviorName) {\n        var behavior;\n\n        if (_.isObject(behaviorData)) {\n          behavior = behaviorData;\n        } else if (_.isString(behaviorData)) {\n          behaviorName = behaviorData;\n          behavior = {};\n        }\n\n        if (behavior) {\n          // Check validity of the class behavior.\n          checkBehaviorData(behavior, behaviorName, Class.getName());\n          behaviorsDefinitions[behaviorName] = behavior;\n        }\n      });\n    }\n\n    if (_.size(behaviorsDefinitions) > 0) {\n      _.each(behaviorsDefinitions, function(behaviorOptions, behaviorName) {\n        // Get a behavior generator.\n        var classBehaviorGenerator = Astro.getBehavior(behaviorName);\n        var classBehavior = classBehaviorGenerator(behaviorOptions);\n        behaviorsDefinitions[behaviorName] = classBehavior;\n        Class.extend(classBehavior.definition);\n      });\n\n      // Add behaviors to the schema.\n      _.extend(schema.behaviors, behaviorsDefinitions);\n    }\n  }\n);\n","var classMethods = {};\n\nclassMethods.hasEvent = function(eventName, eventHandler) {\n  var Class = this;\n\n  return Class.schema.eventManager.has.apply(\n    Class.schema.eventManager, arguments\n  );\n};\n\nclassMethods.emitEvent = function(event) {\n  if (!Astro.config.triggerEvents) {\n    return;\n  }\n\n  if (!event) {\n    return;\n  }\n\n  var Class = this;\n  var eventName = event.type;\n  var target = event.target;\n\n  Class.schema.eventManager.emit(event);\n\n  if (!event.stopped) {\n    return Astro.eventManager.emit(event);\n  }\n\n  return !event.stopped;\n};\n\nAstro.eventManager.on(\n  'initClass', function onInitClassEvents(schemaDefinition) {\n    var Class = this;\n    var schema = Class.schema;\n\n    _.extend(Class, classMethods);\n\n    // Add an event manger to the schema.\n    schema.eventManager = schema.eventManager || Astro.Events.mixin({});\n  }\n);\n","var checkEventDefinition = function(eventDefinition, eventName, className) {\n  // Check if the event name is a string.\n  if (!Match.test(eventName, String)) {\n    throw new Error(\n      'The event name in the \"' + className +\n      '\" class has to be a string'\n    );\n  }\n  // Check if the event definition is an array of functions.\n  if (!Match.test(eventDefinition, [Function])) {\n    throw new Error(\n      'The event handler for the \"' + eventName + '\" event in the \"' +\n      className + '\" class has to be a function'\n    );\n  }\n};\n\nAstro.eventManager.on(\n  'initDefinition', function onInitDefinitionEvents(schemaDefinition) {\n    var Class = this;\n    var schema = Class.schema;\n    var eventsDefinitions = {};\n\n    if (_.has(schemaDefinition, 'events')) {\n      _.each(schemaDefinition.events, function(eventHandlers, eventName) {\n        var eventDefinition;\n\n        if (_.isArray(eventHandlers)) {\n          eventDefinition = eventHandlers;\n        } else if (_.isFunction(eventHandlers)) {\n          eventDefinition = [eventHandlers];\n        }\n\n        if (eventDefinition) {\n          // Check validity of the event definition.\n          checkEventDefinition(eventDefinition, eventName, Class.getName());\n          eventsDefinitions[eventName] = eventDefinition;\n        }\n      });\n    }\n\n    if (_.size(eventsDefinitions) > 0) {\n      // Add events to the event manager in a schema.\n      _.each(eventsDefinitions, function(eventHandlers, eventName) {\n        _.each(eventHandlers, function(eventHandler) {\n          schema.eventManager.on(eventName, eventHandler);\n        });\n      });\n    }\n  }\n);\n","var methods = {};\n\nmethods.typeName = function() {\n  return 'Astronomy';\n};\n\nmethods.toJSONValue = function(args) {\n  var doc = this;\n  var Class = doc.constructor;\n\n  var json = {\n    class: Class.getName(),\n    isNew: doc._isNew\n  };\n\n  var event = new Astro.Event('toJSONValue', json);\n  event.target = doc;\n  Astro.eventManager.emit(event);\n\n  return json;\n};\n\nEJSON.addType('Astronomy', function(json) {\n  var Class = Astro.getClass(json.class);\n  var doc = new Class();\n  doc._isNew = json.isNew;\n\n  var event = new Astro.Event('fromJSONValue', json);\n  event.target = doc;\n  Astro.eventManager.emit(event);\n\n  return doc;\n});\n\n_.extend(Astro.BaseClass.prototype, methods);\n","var classMethods = {};\n\nclassMethods.hasMethod = function(methodName) {\n  return _.has(this.schema.methods, methodName);\n};\n\nclassMethods.getMethod = function(methodName) {\n  return this.schema.methods[methodName];\n};\n\nclassMethods.getMethods = function() {\n  return this.schema.methods;\n};\n\nAstro.eventManager.on(\n  'initClass', function onInitClassMethods(schemaDefinition) {\n    var Class = this;\n    var schema = Class.schema;\n\n    // Extend class with class methods.\n    _.extend(Class, classMethods);\n\n    schema.methods = schema.methods || {};\n  }\n);\n","var checkMethod = function(method, methodName, className) {\n  // The method name has to be a string.\n  if (!Match.test(methodName, String)) {\n    throw new Error(\n      'The method name in the \"' + className + '\" class has to be a string'\n    );\n  }\n  // The method has to be a function.\n  if (!Match.test(method, Function)) {\n    throw new Error(\n      'The \"' + methodName + '\" method in the \"' + className +\n      '\" class has to be a function'\n    );\n  }\n};\n\nAstro.eventManager.on(\n  'initDefinition', function onInitDefinitionMethods(schemaDefinition) {\n    var Class = this;\n    var schema = Class.schema;\n    var methodsDefinitions = {};\n\n    if (_.has(schemaDefinition, 'methods')) {\n      _.each(schemaDefinition.methods, function(method, methodName) {\n        if (_.isFunction(method)) {\n          methodsDefinitions[methodName] = method;\n          // Check validity of the method definition.\n          checkMethod(method, methodName, Class.getName());\n        }\n      });\n    }\n\n    if (_.size(methodsDefinitions) > 0) {\n      _.each(methodsDefinitions, function(method, methodName) {\n        Class.prototype[methodName] = method;\n      });\n\n      // Add methods to the schema.\n      _.extend(schema.methods, schemaDefinition.methods);\n    }\n  }\n);\n","Astro.fields = {};\n","Astro.createType = function(typeDefinition) {\n  if (!_.isObject(typeDefinition)) {\n    throw new Error('Provide type definition');\n  }\n  if (!_.has(typeDefinition, 'name')) {\n    throw new Error('Type name is required');\n  }\n\n  var Type;\n  if (\n    _.has(typeDefinition, 'constructor') &&\n    _.isFunction(typeDefinition.constructor)\n  ) {\n    Type = typeDefinition.constructor;\n  } else {\n    Type = function TypeField() {\n      Astro.BaseField.apply(this, arguments);\n    };\n  }\n  var ParentType = typeDefinition.inherit ?\n    typeDefinition.inherit : Astro.BaseField;\n\n  // Inherit from the BaseClass or a provided class.\n  Astro.utils.class.inherits(Type, ParentType);\n\n  if (_.isFunction(typeDefinition.getDefault)) {\n    Type.prototype._getDefault = typeDefinition.getDefault;\n  }\n  if (_.isFunction(typeDefinition.needsCast)) {\n    Type.prototype._needsCast = typeDefinition.needsCast;\n  }\n  if (_.isFunction(typeDefinition.cast)) {\n    Type.prototype._cast = typeDefinition.cast;\n  }\n  if (_.isFunction(typeDefinition.needsPlain)) {\n    Type.prototype._needsPlain = typeDefinition.needsCast;\n  }\n  if (_.isFunction(typeDefinition.plain)) {\n    Type.prototype._plain = typeDefinition.plain;\n  }\n\n  Astro.fields[typeDefinition.name] = Type;\n};\n","var BaseField = Astro.BaseField = function BaseField(definition) {\n  var self = this;\n\n  definition = _.isUndefined(definition) ? {} : definition;\n\n  this.type = _.isUndefined(definition.type) ?\n    null : definition.type;\n  this.name = _.isUndefined(definition.name) ?\n    null : definition.name;\n  this.default = _.isUndefined(definition.default) ?\n    null : definition.default;\n  this.optional = _.isUndefined(definition.optional) ?\n    false : definition.optional;\n  this.immutable = _.isUndefined(definition.immutable) ?\n    false : definition.immutable;\n  this.transient = _.isUndefined(definition.transient) ?\n    false : definition.transient;\n};\n\nBaseField.prototype.getDefault = function() {\n  var defaultValue;\n\n  // Get a default value from the function if provided.\n  if (_.isFunction(this.default)) {\n    defaultValue = this.default();\n  } else if (_.isNull(this.default)) {\n    return null;\n  } else {\n    defaultValue = this.default;\n  }\n\n  if (_.isFunction(this._getDefault)) {\n    // User defined \"getDefault\" method is responsible for casting a value.\n    return this._getDefault(defaultValue);\n  }\n\n  return this.cast(defaultValue);\n};\n\nBaseField.prototype.needsCast = function(value) {\n  if (_.isUndefined(value) || _.isNull(value)) {\n    return false;\n  }\n\n  if (_.isFunction(this._needsCast)) {\n    return this._needsCast(value);\n  }\n\n  return true;\n};\n\nBaseField.prototype.cast = function(value) {\n  if (this.needsCast(value)) {\n    if (_.isFunction(this._cast)) {\n      return this._cast(value);\n    }\n  }\n\n  return value;\n};\n\nBaseField.prototype.needsPlain = function(value) {\n  if (_.isUndefined(value) || _.isNull(value)) {\n    return false;\n  }\n\n  if (_.isFunction(this._needsPlain)) {\n    return this._needsPlain(value);\n  }\n\n  return true;\n};\n\nBaseField.prototype.plain = function(value) {\n  if (this.needsPlain(value)) {\n    if (_.isFunction(this._plain)) {\n      return this._plain(value);\n    } else {\n      return value.valueOf();\n    }\n  }\n\n  return value;\n};\n","Astro.createType({\n  name: 'null',\n  constructor: function NullField() {\n    Astro.BaseField.apply(this, arguments);\n  },\n  plain: function(value) {\n    return value;\n  }\n});\n","Astro.createType({\n  name: 'string',\n  constructor: function StringField() {\n    Astro.BaseField.apply(this, arguments);\n  },\n  needsCast: function(value) {\n    return !_.isString(value);\n  },\n  cast: function(value) {\n    return String(value);\n  }\n});\n","Astro.createType({\n  name: 'number',\n  constructor: function NumberField() {\n    Astro.BaseField.apply(this, arguments);\n  },\n  needsCast: function(value) {\n    return !_.isNumber(value);\n  },\n  cast: function(value) {\n    return Number(value);\n  }\n});\n","Astro.createType({\n  name: 'boolean',\n  constructor: function BooleanField() {\n    Astro.BaseField.apply(this, arguments);\n  },\n  needsCast: function(value) {\n    return !_.isBoolean(value);\n  },\n  cast: function(value) {\n    if (_.isString(value) && value.toLowerCase() === 'false' || value === '0') {\n      value = false;\n    }\n    return Boolean(value);\n  }\n});\n","Astro.createType({\n  name: 'date',\n  constructor: function DateField() {\n    Astro.BaseField.apply(this, arguments);\n  },\n  needsCast: function(value) {\n    return !_.isDate(value);\n  },\n  cast: function(value) {\n    return new Date(value);\n  },\n  plain: function(value) {\n    return value;\n  }\n});\n","Astro.createType({\n  name: 'object',\n  constructor: function ObjectField(definition) {\n    Astro.BaseField.apply(this, arguments);\n\n    this.class = null;\n\n    if (_.isString(definition.nested)) {\n      var Class = Astro.getClass(definition.nested);\n      if (!Class) {\n        throw new Error('The nested class for [' + definition.name + '] does not exist');\n      }\n      this.class = Class;\n      return;\n    } else if (_.isObject(definition.nested)) {\n      this.class = Astro.Class(definition.nested);\n      return;\n    }\n  },\n  getDefault: function(def) {\n    if (!_.isObject(def)) {\n      def = Object(def);\n    }\n\n    return this.cast(def);\n  },\n  cast: function(value) {\n    var Class = this.class;\n\n    if (Class) {\n      if (!(value instanceof Class)) {\n        value = new Class(value);\n      } else {\n        value = EJSON.clone(value);\n      }\n    } else {\n      if (_.isObject(value)) {\n        value = EJSON.clone(value);\n      } else {\n        value = new Object(value);\n      }\n    }\n\n    return value;\n  },\n  plain: function(value) {\n    var Class = this.class;\n\n    if (Class) {\n      if (value instanceof Class) {\n        value = value.raw();\n      } else {\n        value = EJSON.clone(value.valueOf());\n      }\n    } else {\n      value = EJSON.clone(value.valueOf());\n    }\n\n    return value;\n  }\n});\n","Astro.createType({\n  name: 'array',\n  constructor: function ArrayField(definition) {\n    Astro.BaseField.apply(this, arguments);\n\n    this.field = null;\n    this.class = null;\n\n    if (_.isString(definition.nested)) {\n      var Field = Astro.fields[definition.nested];\n      if (Field) {\n        this.field = new Field();\n        return;\n      }\n\n      var Class = Astro.getClass(definition.nested);\n      if (!Class) {\n        throw new Error('The nested class for [' + definition.name + '] does not exist');\n      }\n      this.class = Class;\n      return;\n    } else if (_.isObject(definition.nested)) {\n      this.class = Astro.Class(definition.nested);\n    } else {\n      var Field = Astro.fields.null;\n      if (Field) {\n        this.field = new Field();\n      }\n    }\n  },\n  getDefault: function(def) {\n    var self = this;\n\n    if (!_.isArray(def)) {\n      def = Array(def);\n    }\n\n    // Cast each value of the array.\n    _.each(def, function(v, i) {\n      def[i] = self.cast(v);\n    });\n\n    return def;\n  },\n  cast: function(values) {\n    var Class = this.class;\n    var field = this.field;\n\n    if (Class) {\n      if (!(values instanceof Class)) {\n        values = new Class(values);\n      } else {\n        values = EJSON.clone(values);\n      }\n    } else if (field) {\n      values = field.cast(values);\n    }\n\n    return values;\n  },\n  plain: function(values) {\n    var Class = this.class;\n    var field = this.field;\n\n    if (Class) {\n      if (values instanceof Class) {\n        values = values.raw();\n      } else {\n        values = EJSON.clone(values);\n      }\n    } else if (field) {\n      values = field.plain(values);\n    }\n\n    return values;\n  }\n});\n","Astro.utils.fields = {};\n\nAstro.utils.fields.isNestedFieldName = function(fieldName) {\n  return fieldName.indexOf('.') !== -1 || fieldName.indexOf('$') !== -1;\n};\n\nAstro.utils.fields.traverseNestedDocs = function(doc, fieldName, callback) {\n  // Method for running callback function with all its arguments.\n  var runCallback = function(nestedDoc, nestedFieldName, index) {\n    var Class;\n    var field;\n    if (nestedDoc instanceof Astro.BaseClass) {\n      Class = nestedDoc.constructor;\n      field = Class.getField(nestedFieldName);\n    }\n    callback(nestedDoc, nestedFieldName, Class, field, index);\n  };\n\n  // Check whether the given field name is pattern.\n  if (fieldName.indexOf('.') === -1) {\n    // If it's not a pattern, then just invoke callback function.\n    runCallback(doc, fieldName);\n    return;\n  }\n\n  // Split the nested field name pattern by the \".\" sign.\n  var segments = fieldName.split('.');\n  var lastIndex = segments.length - 1;\n  var oneBeforeLastIndex = lastIndex - 1;\n\n  // Check wheter the last segment is a number. If it is, then we have to change\n  // the way how we traverse the last field.\n  var lastSegment = segments[lastIndex];\n  var lastSegmentIsNumber = /^\\d+$/.test(lastSegment);\n  if (lastSegmentIsNumber) {\n    lastSegment = parseInt(lastSegment, 10);\n  }\n\n  // Traverse nested fields until reaching the last one from the pattern.\n  var next = function(nestedDoc, segmentIndex) {\n    // Get a nested field name under the given index.\n    var nestedFieldName = segments[segmentIndex];\n\n    if (segmentIndex === lastIndex) {\n      // Ivoke the callback function, if we reached the last nested document.\n      runCallback(nestedDoc, nestedFieldName);\n    } else if (lastSegmentIsNumber && segmentIndex === oneBeforeLastIndex) {\n      runCallback(nestedDoc, nestedFieldName, lastSegment);\n    } else {\n      // Check if the value of the current nested document is an object, so that\n      // we can go deeper.\n      if (_.isObject(nestedDoc[nestedFieldName])) {\n        var nextNestedDoc = nestedDoc[nestedFieldName];\n        var nextSegmentIndex = segmentIndex + 1;\n        if (nextNestedDoc instanceof Astro.BaseClass) {\n          var remainingFieldName = segments.slice(nextSegmentIndex).join('.');\n          Astro.utils.fields.traverseNestedDocs(\n            nextNestedDoc,\n            remainingFieldName,\n            callback\n          );\n        } else {\n          next(nextNestedDoc, nextSegmentIndex);\n        }\n      } else {\n        return;\n      }\n    }\n  };\n\n  // Start traversing nested fields.\n  next(doc, 0);\n};\n","var proto = Astro.BaseClass.prototype;\n\nvar modifiersList = ['$set', '$push', '$pop', '$pullAll', '$inc'];\n\n// Utils.\n\nproto._executeModifier = function(modifier) {\n  var doc = this;\n\n  if (_.isObject(modifier.$set)) {\n    // For each $set modifier, we assign a given value to a field.\n    _.each(modifier.$set, function(fieldValue, fieldName) {\n      doc._setOne(fieldName, fieldValue);\n    });\n  }\n\n  if (_.isObject(modifier.$push)) {\n    // For each $push modifier, we push a given value at the end of a field.\n    _.each(modifier.$push, function(pushedValue, fieldName) {\n      // If the $push modifier contains the $each modifier, then we have push\n      // each value of the array.\n      if (_.isArray(pushedValue.$each)) {\n        _.each(pushedValue.$each, function(element) {\n          doc._pushOne(fieldName, element);\n        });\n      } else {\n        doc._pushOne(fieldName, pushedValue);\n      }\n    });\n  }\n\n  if (_.isObject(modifier.$inc)) {\n    // For each $inc modifier, we increment a given value to of a field.\n    _.each(modifier.$inc, function(incAmount, fieldName) {\n      doc._incOne(fieldName, incAmount);\n    });\n  }\n\n  if (_.isObject(modifier.$pop)) {\n    // For each $pop modifier, we pop the first or last value of a field.\n    _.each(modifier.$pop, function(popSide, fieldName) {\n      doc._popOne(fieldName, popSide);\n    });\n  }\n};\n\nproto._addModifier = function(modifierName, fieldName, fieldValue) {\n  var doc = this;\n\n  var modifierFunctions = {\n    $set: function() {\n      doc._modifiers.$set[fieldName] = fieldValue;\n      return true;\n    },\n    $push: function() {\n      // First, we check whether there is already the $push modifier for the\n      // given field name.\n      if (_.has(doc._modifiers.$push, fieldName)) {\n        if (_.has(doc._modifiers.$push[fieldName], '$each')) {\n          doc._modifiers.$push[fieldName].$each.push(fieldValue);\n        } else {\n          doc._modifiers.$push[fieldName] = {\n            $each: [\n              doc._modifiers.$push[fieldName],\n              fieldValue\n            ]\n          };\n        }\n      } else {\n        doc._modifiers.$push[fieldName] = fieldValue;\n      }\n      return true;\n    },\n    $inc: function() {\n      // First, we check whether there is already the $inc modifier for a given\n      // field name.\n      if (_.has(doc._modifiers.$inc, fieldName)) {\n        doc._modifiers.$inc[fieldName] += fieldValue;\n      } else {\n        doc._modifiers.$inc[fieldName] = fieldValue;\n      }\n      return true;\n    },\n    $pop: function() {\n      // First, we check whether there is already the $pop modifier for a given\n      // field name.\n      if (_.has(doc._modifiers.$pop, fieldName)) {\n        return false;\n      }\n      doc._modifiers.$pop[fieldName] = fieldValue;\n      return true;\n    },\n    $pullAll: function() {\n      if (_.has(doc._modifiers.$pullAll, fieldName)) {\n        doc._modifiers.$pullAll[fieldName].push(fieldValue);\n      } else {\n        doc._modifiers.$pullAll = doc._modifiers.$pullAll || {};\n        doc._modifiers.$pullAll[fieldName] = [];\n        doc._modifiers.$pullAll[fieldName].push(fieldValue);\n      }\n      return true;\n    }\n  };\n\n  // Check whether a given modifier is allowed.\n  if (!_.contains(modifiersList, modifierName)) {\n    return false;\n  }\n\n  // If there is already any modifier for the same field then stop here.\n  // In MongoDB we can not execute multiple modifiers for the same field.\n  if (_.some(_.without(modifiersList, modifierName), function(modifierName) {\n    return doc._hasModifier(modifierName, fieldName);\n  })) {\n    return false;\n  }\n\n  // Create a modifier group if does not exist.\n  doc._modifiers[modifierName] = doc._modifiers[modifierName] || {};\n\n  // Execute a modifier function.\n  return modifierFunctions[modifierName]();\n};\n\nproto._clearUnnecessaryModifiers = function() {\n  old = old || false;\n  var doc = this;\n  var Class = doc.constructor;\n\n  if (doc._id && Class.getCollection()) {\n    var originalDoc = Class.findOne(doc._id);\n  } else {\n    var originalDoc = new Class();\n  }\n\n  var modified = {};\n\n  var fields = Class.getFields();\n  _.each(fields, function(field, fieldName) {\n    if (field.transient) {\n      return;\n    }\n    if (\n      field instanceof Astro.fields.object &&\n      field.class &&\n      doc[fieldName] instanceof Astro.BaseClass\n    ) {\n      // Get a nested document.\n      var nestedDoc = doc[fieldName];\n      // Clear modifiers.\n      nestedDoc._clearUnnecessaryModifiers();\n    } else if (field instanceof Astro.fields.array && field.class) {\n      // Get nested documents.\n      var nestedDocs = doc[fieldName];\n      _.each(nestedDocs, function(nestedDoc, nestedDocIndex) {\n        // Clear modifiers.\n        nestedDoc._clearUnnecessaryModifiers();\n      });\n    } else {\n      if (EJSON.equals(originalDoc[fieldName], doc[fieldName])) {\n        _.each(modifiersList, function(modifierName) {\n          if (\n            doc._modifiers[modifierName] &&\n            _.has(doc._modifiers[modifierName], fieldName)\n          ) {\n            delete doc._modifiers[modifierName][fieldName];\n            if (_.size(doc._modifiers[modifierName]) === 0) {\n              delete doc._modifiers[modifierName];\n            }\n          }\n        });\n      }\n    }\n  });\n\n  return modified;\n};\n\nproto._clearModifiers = function() {\n  var doc = this;\n  var Class = doc.constructor;\n\n  doc._modifiers = {};\n\n  // Get modifiers for nested fields.\n  var fieldsNames = Class.getFieldsNames();\n  // Loop through class fields and for each one check if it is a nested field.\n  _.each(fieldsNames, function(fieldName) {\n    // Get a definition of a field.\n    var field = Class.getField(fieldName);\n\n    // We can not look for a modifier in a nested field that it's empty.\n    if (_.isNull(doc[fieldName])) {\n      return;\n    }\n\n    if (\n      field instanceof Astro.fields.object &&\n      field.class &&\n      doc[fieldName] instanceof Astro.BaseClass\n    ) {\n      // One nested doc.\n\n      // Get a nested document.\n      var nestedDoc = doc[fieldName];\n      // Clear nested modifiers.\n      nestedDoc._clearModifiers();\n    } else if (field instanceof Astro.fields.array && field.class) {\n      // Many nested docs.\n\n      // Get nested documents.\n      var nestedDocs = doc[fieldName];\n      _.each(nestedDocs, function(nestedDoc, nestedDocIndex) {\n        // Clear nested modifiers.\n        nestedDoc._clearModifiers();\n      });\n    }\n  });\n};\n\nproto._hasModifier = function(modifier, fieldName) {\n  if (arguments.length === 1) {\n    return _.has(this._modifiers, modifier);\n  } else if (arguments.length === 2) {\n    return _.has(this._modifiers, modifier) &&\n      _.has(this._modifiers[modifier], fieldName);\n  }\n};\n\nproto._getModifier = function(modifierName, fieldName) {\n  var doc = this;\n  var Class = doc.constructor;\n\n  if (doc._id && Class.getCollection()) {\n    var originalDoc = Class.findOne(doc._id);\n  } else {\n    var originalDoc = new Class();\n  }\n\n  var result = {};\n\n  if (!doc._hasModifier.apply(doc, arguments)) {\n    return result;\n  }\n\n  if (_.isUndefined(fieldName)) {\n    _.each(doc._modifiers[modifierName], function(modifierValue, fieldName) {\n      // Get an original value of the field.\n      var originalValue;\n      Astro.utils.fields.traverseNestedDocs(\n        originalDoc,\n        fieldName,\n        function(nestedField, nestedFieldName, Class, field, index) {\n          originalValue = _.isUndefined(index) ?\n            nestedField[nestedFieldName] : nestedField[nestedFieldName][index];\n        }\n      );\n\n      // Get a current value of the field.\n      var fieldValue;\n      Astro.utils.fields.traverseNestedDocs(\n        doc,\n        fieldName,\n        function(nestedField, nestedFieldName, Class, field, index) {\n          fieldValue = _.isUndefined(index) ?\n            nestedField[nestedFieldName] : nestedField[nestedFieldName][index];\n        }\n      );\n\n      // If a value has changed then get the modifier.\n      if (!doc._isNew && !EJSON.equals(originalValue, fieldValue)) {\n        result[fieldName] = modifierValue;\n      } else {\n        result[fieldName] = modifierValue;\n      }\n    });\n  } else {\n    result[fieldName] = doc._modifiers[modifierName][fieldName];\n  }\n\n  return result;\n};\n\nproto._getModifiers = function(nested) {\n  var doc = this;\n  var Class = doc.constructor;\n\n  nested = _.isUndefined(nested) ? true : nested;\n\n  var docModifiers = {};\n\n  // Collect all modifiers.\n  _.each(modifiersList, function(modifierName) {\n    var modifier = doc._getModifier(modifierName);\n    if (_.size(modifier) > 0) {\n      docModifiers[modifierName] = modifier;\n    }\n  });\n\n  if (!nested) {\n    return docModifiers;\n  }\n\n  // Get modifiers for nested fields.\n  var fieldsNames = Class.getFieldsNames();\n  // Loop through class fields and for each one check if it is a nested field.\n  _.each(fieldsNames, function(fieldName) {\n    // Get a definition of a field.\n    var field = Class.getField(fieldName);\n\n    // We can not look for a modifier in a nested field that it's empty.\n    if (_.isNull(doc[fieldName])) {\n      return;\n    }\n\n    // One nested doc.\n    if (\n      field instanceof Astro.fields.object &&\n      field.class &&\n      doc[fieldName] instanceof Astro.BaseClass\n    ) {\n\n      // Get a nested document.\n      var nestedDoc = doc[fieldName];\n      // Get a modifier for a nested document.\n      var nestedDocModifier = nestedDoc._getModifiers();\n      // We have to loop through modifiers list and check if some modifiers\n      // already exist in the parent modifier. If so, then we will try to merge\n      // them.\n      _.each(nestedDocModifier, function(nestedFieldsValues, modifierName) {\n        _.each(nestedFieldsValues, function(nestedFieldValue, nestedFieldName) {\n          docModifiers[modifierName] = docModifiers[modifierName] || {};\n          var fullFieldName = fieldName + '.' + nestedFieldName;\n          docModifiers[modifierName][fullFieldName] = nestedFieldValue;\n        });\n      });\n\n      // Many nested docs.\n    } else if (field instanceof Astro.fields.array && field.class) {\n\n      // Get nested documents.\n      var nestedDocs = doc[fieldName];\n      _.each(nestedDocs, function(nestedDoc, nestedDocIndex) {\n        // Get a modifier for a nested document.\n        var nestedDocModifier = nestedDoc._getModifiers();\n        // We have to loop through modifiers list and check if some modifiers\n        // already exist in the parent modifier. If so, then we will try to\n        // merge them.\n        _.each(nestedDocModifier, function(nestedFieldsValues, modifierName) {\n          _.each(nestedFieldsValues, function(\n            nestedFieldValue, nestedFieldName\n          ) {\n            docModifiers[modifierName] = docModifiers[modifierName] || {};\n            var fullFieldName =\n              fieldName + '.' + nestedDocIndex + '.' + nestedFieldName;\n            docModifiers[modifierName][fullFieldName] = nestedFieldValue;\n          });\n        });\n      });\n\n    }\n  });\n\n  return docModifiers;\n};\n\nproto._hasModifier = function(modifier, fieldName) {\n  if (arguments.length === 1) {\n    return _.has(this._modifiers, modifier);\n  } else if (arguments.length === 2) {\n    return _.has(this._modifiers, modifier) &&\n      _.has(this._modifiers[modifier], fieldName);\n  }\n};\n\nproto._removeModifier = function(modifier, fieldName) {\n  // If a modifier is not present, then stop here.\n  if (!this._hasModifier.apply(this, arguments)) {\n    return;\n  }\n\n  if (arguments.length === 1) {\n    this._modifiers[modifier] = {};\n  } else if (arguments.length === 2) {\n    this._modifiers[modifier][fieldName] = {};\n  }\n};\n","var proto = Astro.BaseClass.prototype;\n\nproto._setDefault = function(fieldName) {\n  var doc = this;\n  var Class = doc.constructor;\n\n  // Check if a field definition exists.\n  var field = Class.getField(fieldName);\n\n  // If there is no field definition, then we can't get a default value.\n  if (!field) {\n    return;\n  }\n\n  // Get a default value, cast to the proper type and assing the field.\n  doc[fieldName] = field.getDefault();\n};\n","var proto = Astro.BaseClass.prototype;\n\n// Overloaded functions.\n\nproto._setOne = function(fieldName, setValue, options) {\n  var doc = this;\n  var Class = doc.constructor;\n  var event;\n  var modifierFieldValue;\n\n  // Don't allow setting undefined value.\n  if (_.isUndefined(setValue)) {\n    return;\n  }\n\n  // Trigger the \"beforeChange\" event handlers.\n  event = new Astro.Event('beforeChange', {\n    fieldName: fieldName,\n    operation: 'set'\n  });\n  event.target = doc;\n  Class.emitEvent(event);\n  // If an event was prevented from the execution, then we stop here.\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  // Trigger the \"beforeSet\" event handlers.\n  event = new Astro.Event('beforeSet', {\n    fieldName: fieldName,\n    setValue: setValue\n  });\n  event.target = doc;\n  Class.emitEvent(event);\n  // If an event was prevented from the execution, then we stop here.\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  // Set default options of the function. By default, we cast value being set.\n  options = _.extend({\n    cast: true,\n    modifier: true,\n    mutable: false\n  }, options);\n\n  // An indicator for detecting whether a change of a value was necessary.\n  var changed = false;\n\n  Astro.utils.fields.traverseNestedDocs(\n    doc,\n    fieldName,\n    function(nestedDoc, nestedFieldName, Class, field, index) {\n      if (field) {\n        // Check whether the field is immutable, so we can not update it and\n        // should stop execution.\n        if (field.immutable && !options.mutable) {\n          var currFieldValue;\n          if (_.isUndefined(index)) {\n            currFieldValue = nestedDoc[nestedFieldName];\n          } else {\n            currFieldValue = nestedDoc[nestedFieldName][index];\n          }\n          if (!doc._isNew && !_.isNull(currFieldValue)) {\n            return;\n          }\n        }\n\n        // If the field has the \"transient\" flag set to true, then we have to\n        // modify options and turn off the \"modifier\" flag.\n        if (field.transient) {\n          options.modifier = false;\n        }\n\n        // We are setting a value of a single nested field.\n        if (field instanceof Astro.fields.object) {\n\n          // The value being set has to be an object.\n          if (!_.isObject(setValue)) {\n            return;\n          }\n          // Try casting the value to the proper type.\n          if (options.cast) {\n            setValue = field.cast(setValue);\n          }\n          // Get a plain value of a field for a modifier.\n          if (options.modifier) {\n            modifierFieldValue = field.plain(setValue);\n          }\n\n        }\n        // We are setting a value of many nested fields.\n        else if (field instanceof Astro.fields.array) {\n\n          // There are two possiblities. We can try setting entire array or a\n          // single array element.\n          if (_.isUndefined(index)) {\n\n            // The value being set has to be an array.\n            if (!_.isArray(setValue)) {\n              return;\n            }\n            if (options.modifier) {\n              modifierFieldValue = [];\n            }\n            _.each(setValue, function(v, i) {\n              // Try casting the value to the proper type.\n              if (options.cast) {\n                setValue[i] = field.cast(v);\n              }\n              // Get a plain value of a field for a modifier.\n              if (options.modifier) {\n                modifierFieldValue[i] = field.plain(v);\n              }\n            });\n\n          } else {\n\n            // Try casting the value to the proper type.\n            if (options.cast) {\n              setValue = field.cast(setValue);\n            }\n            // Get a plain value of a field for a modifier.\n            if (options.modifier) {\n              modifierFieldValue = field.plain(setValue);\n            }\n\n          }\n\n        }\n        // We are just setting the value.\n        else {\n\n          // Try casting the value to the proper type.\n          if (options.cast) {\n            setValue = field.cast(setValue);\n          }\n\n          // Get a plain value of a field for a modifier.\n          if (options.modifier) {\n            modifierFieldValue = field.plain(setValue);\n          }\n\n        }\n      } else if (Class) {\n        Astro.utils.warn(\n          'Trying to set a value of the \"' + nestedFieldName +\n          '\" field that does not exist in the \"' + Class.getName() + '\" class'\n        );\n        return;\n      }\n\n      // Add modifier.\n      if (options.modifier) {\n        if (_.isUndefined(modifierFieldValue)) {\n          modifierFieldValue = EJSON.clone(setValue);\n        }\n        if (nestedDoc instanceof Astro.BaseClass) {\n          if (_.isUndefined(index)) {\n            changed = nestedDoc._addModifier(\n              '$set', nestedFieldName, modifierFieldValue\n            );\n          } else {\n            changed = nestedDoc._addModifier(\n              '$set', nestedFieldName + '.' + index, modifierFieldValue\n            );\n          }\n        } else {\n          changed = doc._addModifier('$set', fieldName, modifierFieldValue);\n        }\n      } else {\n        // If the \"modifier\" option is not set it means that we just want a\n        // given value to be set without checking if it is possible.\n        changed = true;\n      }\n\n      // If a value change was not possible, then we stop here.\n      if (!changed) {\n        return;\n      }\n\n      // Set the given value on the document but only if the value has changed.\n      if (_.isUndefined(index)) {\n        if (EJSON.equals(nestedDoc[nestedFieldName], setValue)) {\n          return;\n        }\n        nestedDoc[nestedFieldName] = setValue;\n      } else {\n        if (EJSON.equals(nestedDoc[nestedFieldName][index], setValue)) {\n          return;\n        }\n        nestedDoc[nestedFieldName][index] = setValue;\n      }\n    }\n  );\n\n  // If a value change did not take place, then we stop here and the following\n  // events will not be triggered.\n  if (!changed) {\n    return;\n  }\n\n  // Trigger the \"afterSet\" event handlers.\n  event = new Astro.Event('afterSet', {\n    fieldName: fieldName,\n    setValue: setValue\n  });\n  event.target = doc;\n  Class.emitEvent(event);\n\n  // Trigger the \"afterChange\" event handlers.\n  event = new Astro.Event('afterChange', {\n    fieldName: fieldName,\n    operation: 'set'\n  });\n  event.target = doc;\n  Class.emitEvent(event);\n};\n\nproto._setMany = function(fieldsValues, options) {\n  var doc = this;\n\n  // Set multiple fields.\n  _.each(fieldsValues, function(setValue, fieldName) {\n    doc._setOne(fieldName, setValue, options);\n  });\n};\n\n// Public.\n\nproto.set = function(/* arguments */) {\n  var doc = this;\n\n  if (arguments.length === 1 && _.isObject(arguments[0])) {\n    doc._setMany(arguments[0]);\n  } else if (arguments.length === 2 && _.isString(arguments[0])) {\n    doc._setOne(arguments[0], arguments[1]);\n  }\n};\n","var proto = Astro.BaseClass.prototype;\n\n// Overloaded functions.\n\nproto._getOne = function(fieldName, options) {\n  var doc = this;\n  var Class = doc.constructor;\n  var event;\n\n  // Trigger the \"beforeGet\" event handlers.\n  event = new Astro.Event('beforeGet', {\n    fieldName: fieldName\n  });\n  event.target = doc;\n  Class.emitEvent(event);\n\n  // If an event was prevented from the execution, then we stop here.\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  // Set default options of the function. By default, we cast value being get\n  // and get default value is none had been provided.\n  options = _.extend({\n    transient: true\n  }, options);\n\n  // An indicator for breaking the \"get\" method if needed (i.e. trying to get a\n  // transient field when the transient option is set to false).\n  var stop = false;\n\n  // Field value to be returned.\n  var fieldValue;\n\n  Astro.utils.fields.traverseNestedDocs(\n    doc,\n    fieldName,\n    function(nestedField, nestedFieldName, Class, field, index) {\n      if (_.isUndefined(index)) {\n        fieldValue = nestedField[nestedFieldName];\n      } else {\n        fieldValue = nestedField[nestedFieldName][index];\n      }\n\n      if (field) {\n        // Do not get a field if it's transient and the \"transient\" option was\n        // set to false.\n        if (!options.transient && field.transient) {\n          stop = true;\n          return;\n        }\n      }\n    }\n  );\n\n  // If the operation was stopped, then we do not want to execute the \"afterGet\"\n  // event.\n  if (stop) {\n    return;\n  }\n\n  // Trigger the \"afterGet\" event handlers.\n  event = new Astro.Event('afterGet', {\n    fieldName: fieldName\n  });\n  event.target = doc;\n  Class.emitEvent(event);\n\n  return fieldValue;\n};\n\nproto._getMany = function(fieldNames, options) {\n  var doc = this;\n  var values = {};\n\n  _.each(fieldNames, function(fieldName) {\n    var value = doc._getOne(fieldName, options);\n    // Do not get \"undefined\" values.\n    if (_.isUndefined(value)) {\n      return;\n    }\n    values[fieldName] = value;\n  });\n\n  return values;\n};\n\n// Public.\n\nproto.get = function(/* arguments */) {\n  var doc = this;\n\n  if (arguments.length === 0) {\n    return doc;\n  } else if (arguments.length === 1) {\n    if (_.isArray(arguments[0])) {\n      return doc._getMany(arguments[0]);\n    } else if (_.isString(arguments[0])) {\n      return doc._getOne(arguments[0]);\n    }\n  }\n};\n","var proto = Astro.BaseClass.prototype;\n\n// Overloaded functions.\n\nproto._rawOne = function(fieldName, options) {\n  var doc = this;\n  var Class = doc.constructor;\n\n  // Set default options of the function. By default, we cast value being get\n  // and get default value is none had been provided.\n  options = _.extend({\n    transient: true\n  }, options);\n\n  // An indicator for stopping the \"raw\" method if needed (i.e. trying to get a\n  // transient field when the transient option is set to false).\n  var stop = false;\n\n  // Field value to be returned.\n  var fieldValue;\n\n  Astro.utils.fields.traverseNestedDocs(\n    doc,\n    fieldName,\n    function(nestedField, nestedFieldName, Class, field, index) {\n      if (_.isUndefined(index)) {\n        fieldValue = nestedField[nestedFieldName];\n      } else {\n        fieldValue = nestedField[nestedFieldName][index];\n      }\n\n      if (field) {\n        // Do not get a field if it's transient and the \"transient\" option was\n        // set to false.\n        if (!options.transient && field.transient) {\n          stop = true;\n          return;\n        }\n\n        if (field instanceof Astro.fields.object) {\n          if (fieldValue instanceof Astro.BaseClass) {\n            fieldValue = fieldValue._rawAll(options);\n          }\n        } else if (field instanceof Astro.fields.array) {\n          if (_.isArray(fieldValue)) {\n            var values = fieldValue;\n            fieldValue = [];\n            _.each(values, function(value, i) {\n              if (value instanceof Astro.BaseClass) {\n                fieldValue[i] = value._rawAll(options);\n              } else {\n                fieldValue[i] = EJSON.clone(value);\n              }\n            });\n          } else {\n            if (fieldValue instanceof Astro.BaseClass) {\n              fieldValue = fieldValue._rawAll(options);\n            }\n          }\n        } else {\n          // Otherwise get a plain value.\n          fieldValue = field.plain(fieldValue);\n        }\n      }\n    }\n  );\n\n  // If the operation was stopped, then we do not return anything.\n  if (stop) {\n    return;\n  }\n\n  return fieldValue;\n};\n\nproto._rawMany = function(fieldNames, options) {\n  var doc = this;\n  var values = {};\n\n  _.each(fieldNames, function(fieldName) {\n    var value = doc._rawOne(fieldName, options);\n    // Do not get \"undefined\" values.\n    if (_.isUndefined(value)) {\n      return;\n    }\n    values[fieldName] = value;\n  });\n\n  return values;\n};\n\nproto._rawAll = function(options) {\n  var doc = this;\n  var Class = doc.constructor;\n\n  // Get list of fields and their values.\n  return doc._rawMany(Class.getFieldsNames(), options);\n};\n\n// Public.\n\nproto.raw = function(/* arguments */) {\n  var doc = this;\n\n  if (arguments.length === 0) {\n    return doc._rawAll();\n  } else if (arguments.length === 1) {\n    if (_.isArray(arguments[0])) {\n      return doc._rawMany(arguments[0]);\n    } else if (_.isString(arguments[0])) {\n      return doc._rawOne(arguments[0]);\n    }\n  }\n};\n","var proto = Astro.BaseClass.prototype;\n\n// Overloaded functions.\n\nproto._pushOne = function(fieldName, pushValue, options) {\n  var doc = this;\n  var Class = doc.constructor;\n  var event;\n  var modifierPushedValue;\n\n  // Don't allow setting undefined value.\n  if (_.isUndefined(pushValue)) {\n    return;\n  }\n\n  // Trigger the \"beforeChange\" event handlers.\n  event = new Astro.Event('beforeChange', {\n    fieldName: fieldName,\n    operation: 'push'\n  });\n  event.target = doc;\n  Class.emitEvent(event);\n  // If an event was prevented from the execution, then we stop here.\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  // Trigger the \"beforePush\" event handlers.\n  event = new Astro.Event('beforePush', {\n    fieldName: fieldName,\n    pushValue: pushValue\n  });\n  event.target = doc;\n  Class.emitEvent(event);\n  // If an event was prevented from the execution, then we stop here.\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  // Set default options of the function. By default, we cast value being set.\n  options = _.extend({\n    cast: true,\n    modifier: true,\n    mutable: false\n  }, options);\n\n  // An indicator for detecting whether a change of a value was necessary.\n  var changed = false;\n\n  Astro.utils.fields.traverseNestedDocs(\n    doc,\n    fieldName,\n    function(nestedDoc, nestedFieldName, Class, field, index) {\n      // If we try to push an element not into an array, then we stop execution.\n      if (!_.isArray(nestedDoc[nestedFieldName])) {\n        return;\n      }\n\n      if (field) {\n        // Check whether the field is immutable, so we can not update it and\n        // should stop execution.\n        if (field.immutable && !options.mutable) {\n          var currFieldValue;\n          if (_.isUndefined(index)) {\n            currFieldValue = nestedDoc[nestedFieldName];\n          } else {\n            currFieldValue = nestedDoc[nestedFieldName][index];\n          }\n          if (!doc._isNew && !_.isNull(currFieldValue)) {\n            return;\n          }\n        }\n\n        // If the field has the \"transient\" flag set to true, then we have to\n        // modify options and turn off the \"modifier\" flag.\n        if (field.transient) {\n          options.modifier = false;\n        }\n\n        if (options.cast) {\n          // Try casting the value to the proper type.\n          pushValue = field.cast(pushValue);\n        }\n\n        // Get a plain value of a field for a modifier.\n        if (options.modifier) {\n          modifierPushedValue = field.plain(pushValue);\n        }\n      } else if (Class) {\n        Astro.utils.warn(\n          'Trying to push a value into the \"' + nestedFieldName +\n          '\" field that does not exist in the \"' + Class.getName() + '\" class'\n        );\n        return;\n      }\n\n      // Add modifier.\n      if (options.modifier) {\n        if (_.isUndefined(modifierPushedValue)) {\n          modifierPushedValue = EJSON.clone(pushValue);\n        }\n        if (nestedDoc instanceof Astro.BaseClass) {\n          if (_.isUndefined(index)) {\n            changed = nestedDoc._addModifier(\n              '$push', nestedFieldName, modifierPushedValue\n            );\n          } else {\n            changed = nestedDoc._addModifier(\n              '$push', nestedFieldName + '.' + index, modifierPushedValue\n            );\n          }\n        } else {\n          changed = doc._addModifier(\n            '$push', fieldName, modifierPushedValue\n          );\n        }\n      } else {\n        // If the \"modifier\" option is not set it means that we just want a\n        // given value to be set without checking if it is possible.\n        changed = true;\n      }\n\n      // If a value change was not possible, then we stop here.\n      if (!changed) {\n        return;\n      }\n\n      // Set the given value on the document.\n      if (pushValue instanceof Astro.BaseClass) {\n        pushValue._clearModifiers();\n      }\n      nestedDoc[nestedFieldName].push(pushValue);\n    }\n  );\n\n  // If a value change did not take place, then we stop here and the following\n  // events will not be triggered.\n  if (!changed) {\n    return;\n  }\n\n  // Trigger the \"afterPush\" event handlers.\n  event = new Astro.Event('afterPush', {\n    fieldName: fieldName,\n    pushValue: pushValue\n  });\n  event.target = doc;\n  Class.emitEvent(event);\n\n  // Trigger the \"afterChange\" event handlers.\n  event = new Astro.Event('afterChange', {\n    fieldName: fieldName,\n    operation: 'push'\n  });\n  event.target = doc;\n  Class.emitEvent(event);\n};\n\nproto._pushMany = function(pushValues, options) {\n  var doc = this;\n\n  // Set multiple fields.\n  _.each(pushValues, function(pushValue, fieldName) {\n    doc._pushOne(fieldName, pushValue, options);\n  });\n};\n\n// Public.\n\nproto.push = function(/* arguments */) {\n  var doc = this;\n  var args = arguments;\n\n  if (args.length === 1 && _.isObject(args[0])) {\n    doc._pushMany(args[0]);\n  } else if (args.length === 2) {\n    doc._pushOne(args[0], args[1]);\n  }\n};\n","var proto = Astro.BaseClass.prototype;\n\n// Overloaded functions.\n\nproto._popOne = function(fieldName, popValue, options) {\n  var doc = this;\n  var Class = doc.constructor;\n  var event;\n  var result;\n\n  // Cast the \"popValue\" argument to a number.\n  popValue = Number(popValue);\n\n  // Don not allow the \"popValue\" value different than -1 and 1.\n  if (popValue !== 1 && popValue !== 1) {\n    return result;\n  }\n\n  // Trigger the \"beforeChange\" event handlers.\n  event = new Astro.Event('beforeChange', {\n    fieldName: fieldName,\n    operation: 'pop'\n  });\n  event.target = doc;\n  Class.emitEvent(event);\n  // If an event was prevented from the execution, then we stop here.\n  if (event.defaultPrevented) {\n    return result;\n  }\n\n  // Trigger the \"beforePop\" event handlers.\n  event = new Astro.Event('beforePop', {\n    fieldName: fieldName,\n    popValue: popValue\n  });\n  event.target = doc;\n  Class.emitEvent(event);\n  // If an event was prevented from the execution, then we stop here.\n  if (event.defaultPrevented) {\n    return result;\n  }\n\n  // Set default options of the function.\n  options = _.extend({\n    modifier: true,\n    mutable: false\n  }, options);\n\n  // An indicator for detecting whether a change of a value was necessary.\n  var changed = false;\n\n  Astro.utils.fields.traverseNestedDocs(\n    doc,\n    fieldName,\n    function(nestedDoc, nestedFieldName, Class, field, index) {\n      // If we try to pop an element not from an array, then we stop execution.\n      if (!_.isArray(nestedDoc[nestedFieldName])) {\n        return;\n      }\n\n      if (field) {\n        // Check whether the field is immutable, so we can not update it and\n        // should stop execution.\n        if (field.immutable && !options.mutable) {\n          var currFieldValue;\n          if (_.isUndefined(index)) {\n            currFieldValue = nestedDoc[nestedFieldName];\n          } else {\n            currFieldValue = nestedDoc[nestedFieldName][index];\n          }\n          if (!doc._isNew && !_.isNull(currFieldValue)) {\n            return;\n          }\n        }\n\n        // If the field has the \"transient\" flag set to true, then we have to\n        // modify options and turn off the \"modifier\" flag.\n        if (field.transient) {\n          options.modifier = false;\n        }\n      } else if (Class) {\n        Astro.utils.warn(\n          'Trying to pop a value from the \"' + nestedFieldName + '\" field ' +\n          'that does not exist in the \"' + Class.getName() + '\" class'\n        );\n        return;\n      }\n\n      // Add modifier.\n      if (options.modifier) {\n        if (nestedDoc instanceof Astro.BaseClass) {\n          if (_.isUndefined(index)) {\n            changed = nestedDoc._addModifier(\n              '$pop', nestedFieldName, popValue\n            );\n          } else {\n            changed = nestedDoc._addModifier(\n              '$pop', nestedFieldName + '.' + index, popValue\n            );\n          }\n        } else {\n          changed = doc._addModifier('$pop', fieldName, popValue);\n        }\n      } else {\n        // If the \"modifier\" option is not set it means that we just want a\n        // given value to be set without checking if it is possible.\n        changed = true;\n      }\n\n      // If a value change was not possible, then we stop here.\n      if (!changed) {\n        return;\n      }\n\n      // Pop a value from the start or the end of an array.\n      if (popValue === 1) {\n        result = nestedDoc[nestedFieldName].pop();\n      } else {\n        result = nestedDoc[nestedFieldName].unshift();\n      }\n    }\n  );\n\n  // If a value change did not take place, then we stop here and the following\n  // events will not be triggered.\n  if (!changed) {\n    return result;\n  }\n\n  // Trigger the \"afterPop\" event handlers.\n  event = new Astro.Event('afterPop', {\n    fieldName: fieldName,\n    popValue: popValue\n  });\n  event.target = doc;\n  Class.emitEvent(event);\n\n  // Trigger the \"afterChange\" event handlers.\n  event = new Astro.Event('afterChange', {\n    fieldName: fieldName,\n    operation: 'pop'\n  });\n  event.target = doc;\n  Class.emitEvent(event);\n\n  return result;\n};\n\nproto._popMany = function(popValues, options) {\n  var doc = this;\n  var result = {};\n\n  // Set multiple fields.\n  _.each(popValues, function(popValue, fieldName) {\n    result[fieldName] = doc._popOne(fieldName, popValue, options);\n  });\n\n  return result;\n};\n\n// Public.\n\nproto.pop = function(/* arguments */) {\n  var doc = this;\n  var args = arguments;\n\n  if (args.length === 1 && _.isObject(args[0])) {\n    return doc._popMany(args[0]);\n  } else if (args.length === 2) {\n    return doc._popOne(args[0], args[1]);\n  }\n};\n","var proto = Astro.BaseClass.prototype;\n\n// Overloaded functions.\n\nproto._pullOne = function(fieldName, pullValue, options) {\n  var doc = this;\n  var Class = doc.constructor;\n  var event;\n  var result = [];\n\n  // Trigger the \"beforeChange\" event handlers.\n  event = new Astro.Event('beforeChange', {\n    fieldName: fieldName,\n    operation: 'pull'\n  });\n  event.target = doc;\n  Class.emitEvent(event);\n  // If an event was prevented from the execution, then we stop here.\n  if (event.defaultPrevented) {\n    return result;\n  }\n\n  // Trigger the \"beforePull\" event handlers.\n  event = new Astro.Event('beforePull', {\n    fieldName: fieldName,\n    pullValue: pullValue\n  });\n  event.target = doc;\n  Class.emitEvent(event);\n  // If an event was prevented from the execution, then we stop here.\n  if (event.defaultPrevented) {\n    return result;\n  }\n\n  // Set default options of the function.\n  options = _.extend({\n    cast: true,\n    modifier: true,\n    mutable: false\n  }, options);\n\n  // An indicator for detecting whether a change of a value was necessary.\n  var changed = false;\n\n  Astro.utils.fields.traverseNestedDocs(\n    doc,\n    fieldName,\n    function(nestedDoc, nestedFieldName, Class, field, index) {\n      // If we try to pull an element not from an array, then we stop execution.\n      if (!_.isArray(nestedDoc[nestedFieldName])) {\n        return;\n      }\n\n      if (field) {\n        // Check whether the field is immutable, so we can not update it and\n        // should stop execution.\n        if (field.immutable && !options.mutable) {\n          var currFieldValue;\n          if (_.isUndefined(index)) {\n            currFieldValue = nestedDoc[nestedFieldName];\n          } else {\n            currFieldValue = nestedDoc[nestedFieldName][index];\n          }\n          if (!doc._isNew && !_.isNull(currFieldValue)) {\n            return;\n          }\n        }\n\n        // If the field has the \"transient\" flag set to true, then we have to\n        // modify options and turn off the \"modifier\" flag.\n        if (field.transient) {\n          options.modifier = false;\n        }\n\n        if (options.cast) {\n          // Try casting the value to the proper type.\n          pullValue = field.cast(pullValue);\n        }\n\n        // Get a plain value of a field for comparison and a modifier.\n        pullValue = field.plain(pullValue);\n        if (options.modifier) {\n          modifierPulledValue = pullValue;\n        }\n      } else if (Class) {\n        Astro.utils.warn(\n          'Trying to pull a value from the \"' + nestedFieldName + '\" field ' +\n          'that does not exist in the \"' + Class.getName() + '\" class'\n        );\n        return;\n      }\n\n      // Check if a value is present in an array.\n      if (!_.find(nestedDoc[nestedFieldName], function(value) {\n        if (field) {\n          value = field.plain(value);\n        }\n        return EJSON.equals(value, pullValue);\n      })) {\n        return;\n      }\n\n      // Add modifier.\n      if (options.modifier) {\n        if (_.isUndefined(modifierPulledValue)) {\n          modifierPulledValue = EJSON.clone(pullValue);\n        }\n        if (nestedDoc instanceof Astro.BaseClass) {\n          if (_.isUndefined(index)) {\n            changed = nestedDoc._addModifier(\n              '$pullAll', nestedFieldName, modifierPulledValue\n            );\n          } else {\n            changed = nestedDoc._addModifier(\n              '$pullAll', nestedFieldName + '.' + index, modifierPulledValue\n            );\n          }\n        } else {\n          changed = doc._addModifier(\n            '$pullAll', fieldName, modifierPulledValue\n          );\n        }\n      } else {\n        // If the \"modifier\" option is not set it means that we just want a\n        // given value to be set without checking if it is possible.\n        changed = true;\n      }\n\n      // If a value change was not possible, then we stop here.\n      if (!changed) {\n        return;\n      }\n\n      // Pull a value from an array.\n      nestedDoc[nestedFieldName] = _.filter(\n        nestedDoc[nestedFieldName],\n        function(value) {\n          if (field) {\n            value = field.plain(value);\n          }\n          if (EJSON.equals(value, pullValue)) {\n            if (field) {\n              result.push(field.cast(pullValue));\n            } else {\n              result.push(pullValue);\n            }\n            return false;\n          } else {\n            return true;\n          }\n        }\n      );\n    }\n  );\n\n  // If a value change did not take place, then we stop here and the following\n  // events will not be triggered.\n  if (!changed) {\n    return result;\n  }\n\n  // Trigger the \"afterPull\" event handlers.\n  event = new Astro.Event('afterPull', {\n    fieldName: fieldName,\n    pullValue: pullValue\n  });\n  event.target = doc;\n  Class.emitEvent(event);\n\n  // Trigger the \"afterChange\" event handlers.\n  event = new Astro.Event('afterChange', {\n    fieldName: fieldName,\n    operation: 'pull'\n  });\n  event.target = doc;\n  Class.emitEvent(event);\n\n  return result;\n};\n\nproto._pullMany = function(pullValues, options) {\n  var doc = this;\n  var result = {};\n\n  // Pull multiple values.\n  _.each(pullValues, function(pullValue, fieldName) {\n    result[fieldName] = doc._pullOne(fieldName, pullValue, options);\n  });\n\n  return result;\n};\n\n// Public.\n\nproto.pull = function(/* arguments */) {\n  var doc = this;\n  var args = arguments;\n\n  if (args.length === 1 && _.isObject(args[0])) {\n    return doc._pullMany(args[0]);\n  } else if (args.length === 2) {\n    return doc._pullOne(args[0], args[1]);\n  }\n};\n","var proto = Astro.BaseClass.prototype;\n\n// Overloaded functions.\n\nproto._incOne = function(fieldName, incValue, options) {\n  var doc = this;\n  var Class = doc.constructor;\n  var event;\n\n  // Cast the \"incValue\" argument to a number.\n  incValue = Number(incValue);\n\n  // Don not allow incrementing by non number value or by 0.\n  if (_.isNaN(incValue) || incValue === 0) {\n    return;\n  }\n\n  // Trigger the \"beforeChange\" event handlers.\n  event = new Astro.Event('beforeChange', {\n    fieldName: fieldName,\n    operation: 'inc'\n  });\n  event.target = doc;\n  Class.emitEvent(event);\n  // If an event was prevented from the execution, then we stop here.\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  // Trigger the \"beforeInc\" event handlers.\n  event = new Astro.Event('beforeInc', {\n    fieldName: fieldName,\n    incValue: incValue\n  });\n  event.target = doc;\n  Class.emitEvent(event);\n  // If an event was prevented from the execution, then we stop here.\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  // Set default options of the function.\n  options = _.extend({\n    modifier: true,\n    mutable: false\n  }, options);\n\n  // An indicator for detecting whether a change of a value was necessary.\n  var changed = false;\n\n  Astro.utils.fields.traverseNestedDocs(\n    doc,\n    fieldName,\n    function(nestedDoc, nestedFieldName, Class, field, index) {\n      // Get a current value of the field.\n      var currFieldValue = _.isUndefined(index) ?\n        nestedDoc[nestedFieldName] : nestedDoc[nestedFieldName][index];\n\n      // If we try to increment non number value, then we stop execution.\n      if (!_.isNumber(currFieldValue)) {\n        return;\n      }\n\n      if (field) {\n        // Check whether the field is immutable, so we can not update it and\n        // should stop execution.\n        if (\n          field.immutable && !options.mutable &&\n          !doc._isNew && !_.isNull(currFieldValue)\n        ) {\n          return;\n        }\n\n        // If the field has the \"transient\" flag set to true, then we have to\n        // modify options and turn off the \"modifier\" flag.\n        if (field.transient) {\n          options.modifier = false;\n        }\n      } else if (Class) {\n        Astro.utils.warn(\n          'Trying to increment a value of the \"' + nestedFieldName +\n          '\" field that does not exist in the \"' + Class.getName() + '\" class'\n        );\n        return;\n      }\n\n      // Add modifier.\n      if (options.modifier) {\n        if (nestedDoc instanceof Astro.BaseClass) {\n          if (_.isUndefined(index)) {\n            changed = nestedDoc._addModifier(\n              '$inc', nestedFieldName, incValue\n            );\n          } else {\n            changed = nestedDoc._addModifier(\n              '$inc', nestedFieldName + '.' + index, incValue\n            );\n          }\n        } else {\n          changed = doc._addModifier('$inc', fieldName, incValue);\n        }\n      } else {\n        // If the \"modifier\" option is not set it means that we just want a\n        // given value to be set without checking if it is possible.\n        changed = true;\n      }\n\n      // If a value change was not possible, then we stop here.\n      if (!changed) {\n        return;\n      }\n\n      // Increment a value of the field by a given amount.\n      if (_.isUndefined(index)) {\n        nestedDoc[nestedFieldName] += incValue;\n      } else {\n        nestedDoc[nestedFieldName][index] += incValue;\n      }\n    }\n  );\n\n  // If a value change did not take place, then we stop here and the following\n  // events will not be triggered.\n  if (!changed) {\n    return;\n  }\n\n  // Trigger the \"afterInc\" event handlers.\n  event = new Astro.Event('afterInc', {\n    fieldName: fieldName,\n    incValue: incValue\n  });\n  event.target = doc;\n  Class.emitEvent(event);\n\n  // Trigger the \"afterChange\" event handlers.\n  event = new Astro.Event('afterChange', {\n    fieldName: fieldName,\n    operation: 'inc'\n  });\n  event.target = doc;\n  Class.emitEvent(event);\n};\n\nproto._incMany = function(fieldsValues, options) {\n  var doc = this;\n\n  // Set multiple fields.\n  _.each(fieldsValues, function(incValue, fieldName) {\n    doc._incOne(fieldName, incValue, options);\n  });\n};\n\n// Public.\n\nproto.inc = function(/* arguments */) {\n  var doc = this;\n  var args = arguments;\n\n  if (args.length === 1 && _.isObject(args[0])) {\n    doc._incMany(args[0]);\n  } else if (args.length === 2) {\n    doc._incOne(args[0], args[1]);\n  }\n};\n","var proto = Astro.BaseClass.prototype;\n\nproto.getModified = function(old) {\n  old = old || false;\n  var doc = this;\n  var Class = doc.constructor;\n\n  doc._clearUnnecessaryModifiers();\n\n  if (doc._id && Class.getCollection()) {\n    var originalDoc = Class.findOne(doc._id);\n  } else {\n    var originalDoc = new Class();\n  }\n\n  var modified = {};\n\n  var fields = Class.getFields();\n  _.each(fields, function(field, fieldName) {\n    if (field.transient) {\n      return;\n    }\n    // If a value differs from the value in the original object then it means\n    // that fields was modified from the last save.\n    if (!EJSON.equals(originalDoc[fieldName], doc[fieldName])) {\n      // Take a value before or after modification.\n      var fieldValue;\n      if (old) {\n        fieldValue = originalDoc[fieldName];\n      } else {\n        fieldValue = doc[fieldName];\n      }\n\n      modified[fieldName] = fieldValue;\n    }\n  });\n\n  return modified;\n};\n\nproto.isModified = function() {\n  var doc = this;\n\n  // Get a modifier.\n  var modifier = doc._getModifiers();\n  // If there are any modifiers, then it means that document was modified.\n  return _.size(modifier) > 0;\n};\n","var events = {};\n\nevents.toJSONValue = function(e) {\n  var doc = this;\n  var Class = doc.constructor;\n\n  var values = {};\n  _.each(Class.getFieldsNames(), function(fieldName) {\n    values[fieldName] = doc[fieldName];\n  });\n\n  var json = {\n    modifiers: EJSON.stringify(doc._modifiers),\n    values: EJSON.stringify(values)\n  };\n\n  _.extend(e.data, json);\n};\n\nevents.fromJSONValue = function(e) {\n  var doc = this;\n  var json = e.data;\n\n  doc._modifiers = EJSON.parse(json.modifiers);\n  _.extend(doc, EJSON.parse(json.values));\n};\n\nAstro.eventManager.on('toJSONValue', events.toJSONValue);\nAstro.eventManager.on('fromJSONValue', events.fromJSONValue);\n","var classMethods = {};\n\nclassMethods.getFieldsNames = function() {\n  return this.schema.fieldsNames;\n};\n\nclassMethods.hasField = function(fieldName) {\n  return _.has(this.schema.fields, fieldName);\n};\n\nclassMethods.getField = function(fieldName) {\n  return this.schema.fields[fieldName];\n};\n\nclassMethods.getFields = function() {\n  return this.schema.fields;\n};\n\nAstro.eventManager.on(\n  'initClass', function onInitClassFields(schemaDefinition) {\n    var Class = this;\n    var schema = Class.schema;\n\n    // Add fields methods to the class.\n    _.extend(Class, classMethods);\n\n    schema.fields = schema.fields || {};\n    schema.fieldsNames = schema.fieldsNames || [];\n  }\n);\n","var checkFieldDefinition = function(fieldDefinition, className) {\n  var fieldName = fieldDefinition.name;\n\n  // FIELD NAME.\n  // Field name has to be a string.\n  if (!_.isString(fieldName)) {\n    throw new TypeError(\n      'The field name in the \"' + className + '\" class has to be a string'\n    );\n  }\n  // Check field validity.\n  if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(fieldName)) {\n    throw new Error(\n      'The \"' + fieldName + '\" field name in the \"' + className +\n      '\" class contains not allowed characters'\n    );\n  }\n\n  // FIELD TYPE.\n  if (!Astro.fields[fieldDefinition.type]) {\n    throw new Error(\n      'The type provided in the definition of the \"' + fieldName +\n      '\" field in the \"' + className + '\" class does not exist'\n    );\n  }\n\n  // DEFAULT VALUE.\n  // Check if a default value of field have been properly defined.\n  if (\n    !_.isFunction(fieldDefinition.default) &&\n    _.isObject(fieldDefinition.default)\n  ) {\n    Astro.utils.warn(\n      'A non plain default value for the \"' + fieldName +\n      '\" field in the \"' + className +\n      '\" class should be defined and returned in a function'\n    );\n  }\n};\n\nvar parseNestedFieldName = function(nestedFieldName, definition) {\n  var segments = nestedFieldName.split('.');\n\n  if (segments[0] === '$' || segments[segments.length - 1] === '$') {\n    throw new Error(\n      'The \"$\" sign can not be placed at the beginning or end of the \"' +\n      nestedFieldName + '\" nested field pattern'\n    );\n  }\n\n  var fieldsDefinitions = {};\n  var schemaDefinition = fieldsDefinitions;\n  var className = '';\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    var nextSegment = segments[i + 1];\n\n    if (i < segments.length - 1) {\n      var nestedFieldDefinition = {};\n      if (nextSegment === '$') {\n        nestedFieldDefinition.type = 'array';\n        nestedFieldDefinition.name = segment;\n        i++;\n      } else {\n        nestedFieldDefinition.type = 'object';\n        nestedFieldDefinition.name = segment;\n      }\n      className += Astro.utils.string.ucfirst(segment);\n      nestedFieldDefinition.nested = {\n        name: className,\n        fields: {}\n      };\n      fieldsDefinitions[segment] = nestedFieldDefinition;\n      fieldsDefinitions = nestedFieldDefinition.nested.fields;\n    } else {\n      fieldsDefinitions[segment] = definition;\n    }\n  }\n\n  return schemaDefinition[segments[0]];\n};\n\nAstro.eventManager.on(\n  'initDefinition', function onInitDefinitionFields(schemaDefinition) {\n    var Class = this;\n    var schema = Class.schema;\n    var fieldsDefinitions = {};\n\n    if (_.has(schemaDefinition, 'fields')) {\n      if (_.isArray(schemaDefinition.fields)) {\n        _.each(schemaDefinition.fields, function(fieldName) {\n          var fieldDefinition;\n\n          if (_.isString(fieldName)) {\n            if (Astro.utils.fields.isNestedFieldName(fieldName)) {\n              fieldName = parseNestedFieldName(fieldName, {\n                type: 'null'\n              });\n            } else {\n              fieldDefinition = {\n                name: fieldName,\n                type: 'null'\n              };\n            }\n          }\n\n          if (fieldDefinition) {\n            // Check validity of the field definition.\n            checkFieldDefinition(fieldDefinition, Class.getName());\n            if (fieldsDefinitions[fieldDefinition.name]) {\n              // If a field definition already exists, then try deep merging\n              // these definitions.\n              fieldsDefinitions[fieldDefinition.name] =\n                Astro.utils.object.deepMerge(\n                  fieldsDefinitions[fieldDefinition.name], fieldDefinition\n                );\n            } else {\n              fieldsDefinitions[fieldDefinition.name] = fieldDefinition;\n            }\n          }\n        });\n\n      } else if (_.isObject(schemaDefinition.fields)) {\n\n        _.each(schemaDefinition.fields, function(fieldDefinition, fieldName) {\n          var fieldDefinition;\n\n          if (_.isString(fieldDefinition)) {\n\n            if (Astro.utils.fields.isNestedFieldName(fieldName)) {\n              fieldDefinition = parseNestedFieldName(fieldName, {\n                type: fieldDefinition\n              });\n            } else {\n              fieldDefinition = {\n                name: fieldName,\n                type: fieldDefinition\n              };\n            }\n\n          } else if (_.isObject(fieldDefinition)) {\n\n            if (Astro.utils.fields.isNestedFieldName(fieldName)) {\n              fieldDefinition = parseNestedFieldName(fieldName, _.extend({\n                type: 'null'\n              }, fieldDefinition));\n            } else {\n              fieldDefinition = _.extend({\n                type: 'null'\n              }, fieldDefinition, {\n                name: fieldName\n              });\n            }\n\n          }\n\n          if (fieldDefinition) {\n            // Check validity of the field definition.\n            checkFieldDefinition(fieldDefinition, Class.getName());\n            if (fieldsDefinitions[fieldDefinition.name]) {\n              // If a field definition already exists, then try deep merging\n              // these definitions.\n              fieldsDefinitions[fieldDefinition.name] =\n                Astro.utils.object.deepMerge(\n                  fieldsDefinitions[fieldDefinition.name], fieldDefinition\n                );\n            } else {\n              fieldsDefinitions[fieldDefinition.name] = fieldDefinition;\n            }\n          }\n        });\n\n      }\n    }\n\n    if (_.size(fieldsDefinitions) > 0) {\n      _.each(fieldsDefinitions, function(fieldDefinition, fieldName) {\n        // Get a field class from the type.\n        var Field = Astro.fields[fieldDefinition.type];\n        // Create a new field.\n        var field = new Field(fieldDefinition);\n\n        fieldsDefinitions[fieldName] = field;\n      });\n\n      // Add fields and fields names to the schema.\n      _.extend(schema.fields, fieldsDefinitions);\n      var fieldsNames = _.keys(fieldsDefinitions);\n      schema.fieldsNames = _.union(schema.fieldsNames, fieldsNames);\n    }\n  }\n);\n","var classMethods = {};\n\nclassMethods.hasIndex = function(indexName) {\n  return _.has(this.schema.indexes, indexName);\n};\n\nclassMethods.getIndex = function(indexName) {\n  return this.schema.indexes[indexName];\n};\n\nclassMethods.getIndexes = function() {\n  return this.schema.indexes;\n};\n\nAstro.eventManager.on(\n  'initClass', function onInitClassIndexes(schemaDefinition) {\n    var Class = this;\n    var schema = Class.schema;\n\n    // Add fields methods to the class.\n    _.extend(Class, classMethods);\n\n    schema.indexes = schema.indexes || {};\n  }\n);\n","var checkDefinition = function(indexDefinition, indexName, className) {\n  if (!Match.test(indexName, String)) {\n    throw new TypeError(\n      'The index name in the \"' + className + '\" class has to be a string'\n    );\n  }\n  if (!Match.test(indexDefinition, Object)) {\n    throw new TypeError(\n      'The index definition in the \"' + className +\n      '\" class has to be an object'\n    );\n  }\n};\n\nAstro.eventManager.on(\n  'initDefinition', function onInitDefinitionIndexes(schemaDefinition) {\n    var Class = this;\n    var schema = Class.schema;\n    var indexesDefinitions = {};\n\n    if (_.has(schemaDefinition, 'fields')) {\n      _.each(schemaDefinition.fields, function(fieldDefinition, fieldName) {\n        if (_.has(fieldDefinition, 'index')) {\n          var indexDefinition;\n\n          if (\n            fieldDefinition.index === -1 || fieldDefinition.index === 1 ||\n            _.isString(fieldDefinition.index)\n          ) {\n            indexDefinition = {\n              fields: {},\n              options: {\n                name: fieldName\n              }\n            };\n            indexDefinition.fields[fieldName] = fieldDefinition.index;\n          }\n\n          if (indexDefinition) {\n            // Check validity of the event definition.\n            checkDefinition(indexDefinition, fieldName, Class.getName());\n            indexesDefinitions[fieldName] = indexDefinition;\n          }\n        }\n      });\n    }\n\n    if (_.has(schemaDefinition, 'indexes')) {\n      _.each(schemaDefinition.indexes, function(definition, indexName) {\n        var indexDefinition;\n\n        // Prepare index definition.\n        if (_.isObject(definition)) {\n          var indexDefinition = _.pick(definition, ['fields', 'options']);\n          indexDefinition.options = indexDefinition.options || {};\n          if (!_.has(indexDefinition.options, 'name')) {\n            indexDefinition.options.name = indexName;\n          }\n        }\n\n        // Check validity of the event definition.\n        if (indexDefinition) {\n          checkDefinition(indexDefinition, indexName, Class.getName());\n          indexesDefinitions[indexName] = indexDefinition;\n        }\n      });\n    }\n\n    if (_.size(indexesDefinitions) > 0) {\n      var Collection = Class.getCollection();\n      if (!Collection) {\n        return;\n      }\n      // Add indexes to the collection\n      _.each(indexesDefinitions, function(indexDefinition) {\n        Collection._ensureIndex(\n          indexDefinition.fields, indexDefinition.options\n        );\n      });\n\n      // Add indexes to the schema.\n      _.extend(schema.indexes, indexesDefinitions);\n    }\n  }\n);\n"]}