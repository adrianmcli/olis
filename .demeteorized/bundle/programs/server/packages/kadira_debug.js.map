{"version":3,"sources":["meteor://ðŸ’»app/packages/kadira_debug/lib/utils.js","meteor://ðŸ’»app/packages/kadira_debug/lib/server/utils.js","meteor://ðŸ’»app/packages/kadira_debug/lib/server/data_layer.js","meteor://ðŸ’»app/packages/kadira_debug/lib/server/trace_store.js","meteor://ðŸ’»app/packages/kadira_debug/lib/server/connect.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACpLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/packages/kadira_debug.js","sourcesContent":["Utils = Utils || {};\n\nUtils.getAppEnv = function() {\n  var env = 'development';\n  if(!Package['kadira:runtime-dev']) {\n    env = 'production';\n  }\n  return env;  \n};","Utils = Utils || {};\n\nUtils.getDebugAuthKey = function () {\n  var authKey = process.env.KADIRA_DEBUG_AUTH_KEY;\n  if(authKey) {\n    return authKey;\n  }\n\n  // Getting it from Meteor.settings.\n  authKey = Meteor.settings && \n    Meteor.settings.kadira && \n    Meteor.settings.kadira.debug &&\n    Meteor.settings.kadira.debug.authKey;\n\n  return authKey;\n};","KdDataLayer = function(args) {\n  this._serverId = args.serverId;\n  this._docID = {\n    'client': 'clientAuthorizedSessions',\n    'remote': 'remoteAuthorizedSessions',\n  };\n\n  this.configColl = new Mongo.Collection('__kdconfig');\n  this.timeEventsColl = new Mongo.Collection('__kdtimeevents');\n  this.timeEventsColl._createCappedCollection(52428800); // 50 MB\n  this.tracesColl = new Mongo.Collection('__kdtraces');\n  this.tracesColl._createCappedCollection(52428800); // 50 MB\n\n  // set TTL Index for expire accessTokens and authSessions\n  this.configColl._ensureIndex({expires: 1}, {expireAfterSeconds: 3600});\n};\n\nKdDataLayer.prototype.registerAccessToken = function(accessToken) {\n  var expiryDate = new Date(Date.now() + 1000 * 3600 * 24);\n\n  this.configColl.insert({\n    type: 'accessTokens',\n    token: accessToken,\n    expires: expiryDate\n  });\n};\n\nKdDataLayer.prototype.isValidToken = function(accessToken) {\n  return !!this.configColl.findOne({\n    type: 'accessTokens',\n    token: accessToken\n  });\n};\n\nKdDataLayer.prototype.registerSession = function(type, sessionId) {\n  var expiryDate = new Date(Date.now() + 1000 * 3600 * 24);\n\n  this.configColl.insert({\n    type: this._docID[type],\n    session: sessionId,\n    expires: expiryDate\n  });\n};\n\nKdDataLayer.prototype.isValidSession = function(type, sessionId) {\n  return !!this.configColl.findOne({\n    type: this._docID[type],\n    session: sessionId\n  });\n};\n\nKdDataLayer.prototype.unregisterSession = function(type, sessionId) {\n  this.configColl.remove({\n    type: this._docID[type],\n    session: sessionId\n  });\n};\n\nKdDataLayer.prototype.increaseListenersCount = function(val) {\n  this.configColl.update(\n    { _id: 'listenersCount' },\n    { $inc: {count: val}},\n    { upsert: true }\n  );\n};\n\nKdDataLayer.prototype.getListenersCount = function() {\n  var config = this.configColl.findOne({_id: 'listenersCount'});\n  var timelineCount = (config && config.count) ? config.count : 0;\n  return timelineCount;\n};\n\nKdDataLayer.prototype.setTimeEvent = function(data) {\n  this.timeEventsColl.rawCollection().insert(data, function(err) {\n    if(err) {\n      console.error(err.stack);\n    }\n  });\n};\n\nKdDataLayer.prototype.setTrace = function(key, type, trace) {\n  this.tracesColl.rawCollection().update(\n    { _id: key},\n    {\n      type: type,\n      data: JSON.stringify(trace)\n    },\n    { upsert: true},\n    function(err) {\n      if(err) {\n        console.error(err.stack);\n      }\n    }\n  );\n};\n\nKdDataLayer.prototype.getTrace = function(key, type) {\n  var traceData = this.tracesColl.findOne({\n    _id: key,\n    type: type\n  });\n  var trace = (traceData) ? JSON.parse(traceData.data) : undefined;\n  return trace;\n};\n\nKdDataLayer.prototype.reset = function() {\n  this.configColl.remove({});\n  // XXX: Here don't remove data in the capped collections\n  // because their data will be removed eventually.\n};\n","var LRUCache = Npm.require('lru-cache');\n\nTraceStore = function(args) {\n  this.kdData = args.kdData;\n\n  this._sessionMapper = {};\n  this._registeredSessions = {};\n\n  this._onMethodTrace = this._onMethodTrace.bind(this);\n  this._onSubTrace = this._onSubTrace.bind(this);\n\n  // This is an measurement to make sure, we won't have a \n  // memory leak in case of something goes wrong.\n  this._timeEventsCache = new LRUCache({max: 1000});\n};\n\nTraceStore.prototype.registerSession = function(sessionId, browserId, clientId) {\n  var key = this._getClientKey(browserId, clientId);\n  this._sessionMapper[key] = sessionId;\n  // we store registered sessions in a map\n  // to keep track for futher uses\n  this._registeredSessions[sessionId] = true;\n};\n\nTraceStore.prototype.unregisterSession = function(browserId, clientId) {\n  var key = this._getClientKey(browserId, clientId);\n  var sessionId = this._sessionMapper[key];\n  delete this._sessionMapper[key];\n  delete this._registeredSessions[sessionId];\n};\n\nTraceStore.prototype.start = function() {\n  // It's okay call `Kadira._startInstrumenting` multiple times\n  Kadira._startInstrumenting(function() {});\n\n  Kadira.EventBus.on('method', 'methodCompleted', this._onMethodTrace);\n  Kadira.EventBus.on('pubsub', 'subCompleted', this._onSubTrace);\n};\n\nTraceStore.prototype.stop = function() {\n  Kadira.EventBus.removeListener('method', 'methodCompleted', this._onMethodTrace);\n  Kadira.EventBus.removeListener('pubsub', 'subCompleted', this._onSubTrace);\n};\n\nTraceStore.prototype.getTrace = function(browserId, clientId, type, id) {\n  var key = this._getClientKey(browserId, clientId);\n  var sessionId = this._sessionMapper[key];\n  if(!sessionId) {\n    return;\n  }\n\n  if(type === 'method' || type === 'pubsub') {\n    var traceKey = this._getTraceKey(sessionId, id);\n    var trace = this.kdData.getTrace(traceKey, type);\n    return trace;\n  } else {\n    throw new Meteor.Error(400, \"Invalid trace type: \" + type);\n  }\n};\n\n// Pick all the timevents collection for this client\n// Once picked, those data will be removed from the cache\nTraceStore.prototype.pickTimeEvents = function(browserId, clientId) {\n  var key = this._getClientKey(browserId, clientId);\n  var sessionId = this._sessionMapper[key];\n\n  if(!this._timeEventsCache.has(sessionId)) {\n    return [];\n  }\n\n  var cacheItem = this._timeEventsCache.get(sessionId);\n  this._timeEventsCache.del(sessionId);\n\n  return cacheItem.times;\n};\n\n/*\n  Tracks time related metrics for DDP messages \n  (but possible for others as well)\n\n  @param type - type of the message (pubsub, method)\n  @param id - sessionId of the message\n  @param id - id of the message\n  @param event - event we are tracking the time (eg:- start, end)\n  @timestamp [optional] - timestamp of the event in milliseconds\n  @info [optional] - an object containing some special information\n*/\nTraceStore.prototype._trackTime = function(type, sessionId, id, event, timestamp, info) {\n  if(typeof timestamp === \"object\") {\n    info = timestamp;\n    timestamp = null;\n  }\n\n  timestamp = timestamp || Date.now();\n  if(!this._timeEventsCache.has(sessionId)) {\n    this._timeEventsCache.set(sessionId, {times: []});\n  }\n\n  var item = {\n    type: type,\n    id: id,\n    event: event,\n    timestamp: timestamp\n  };\n\n  if(info) {\n    item.info = info;\n  }\n\n  this._timeEventsCache.get(sessionId).times.push(item);\n};\n\nTraceStore.prototype._onMethodTrace = function(trace, session) {\n  if(!this._registeredSessions[session.id]) {\n    // not a valid session,\n    // return without building a trace\n    return;    \n  }\n\n  // We don't need to track Kadira Debug ping method\n  if(trace && trace.name === \"kadira.debug.client.updateTimeline\") {\n    return;\n  }\n  this._buildTrace(trace);\n\n  var key = this._getTraceKey(session.id, trace.id);\n  this.kdData.setTrace(key, 'method', trace);\n\n  this._trackTraceTimes('method', session.id, trace);\n};\n\nTraceStore.prototype._onSubTrace = function(trace, session) {\n  if(!this._registeredSessions[session.id]) {\n    // not a valid session,\n    // return without building a trace\n    return;    \n  }\n\n  // here, trace can be empty\n  if(trace) {\n    this._buildTrace(trace);\n\n    var key = this._getTraceKey(session.id, trace.id);\n    this.kdData.setTrace(key, 'pubsub', trace);\n\n    this._trackTraceTimes('pubsub', session.id, trace);\n  }\n};\n\nTraceStore.prototype._getTraceKey = function(session, traceId) {\n  return session + traceId;\n};\n\nTraceStore.prototype._getClientKey = function(browserId, clientId) {\n  return browserId + clientId;\n};\n\n// We need alter the tracer to make it compatible with the format\n// tracer viewer accepts.\nTraceStore.prototype._buildTrace = function(trace) {\n  trace.startTime = new Date(trace.at);\n  if(trace && trace.metrics && trace.metrics.total) {\n    trace.totalValue = trace.metrics.total;\n  }\n\n  return trace;\n};\n\nTraceStore.prototype._trackTraceTimes = function(type, sessionId, trace) {\n  var info = {name: trace.name};\n  this._trackTime(type, sessionId, trace.id, 'server-received', trace.at, info);\n  this._trackTime(type, sessionId, trace.id, 'server-waitend', trace.at + trace.metrics.wait);\n  this._trackTime(type, sessionId, trace.id, 'server-processed', trace.at + trace.metrics.total);\n};\n\nTraceStore.prototype.reset = function() {\n  this._sessionMapper = {};\n  this._registeredSessions = {};\n  \n  this._timeEventsCache.reset();\n};\n","KadiraDebug = KadiraDebug || {};\nvar UAParser = Npm.require('ua-parser-js');\n\nAppConfig = {\n  // app environment. Either `production` or `development`.\n  env: Utils.getAppEnv(),\n\n  // auth key taken from enviornment variables\n  authKey: Utils.getDebugAuthKey()\n};\n\nSubHandlers = {\n  // Keep DDP sessions of the remote admin's subscription for timeline\n  timeline: [],\n  // Keep DDP sessions of the client app's subscription for sending the\n  // count of remote admins\n  listeners: []\n};\n\nvar uniqueId = 0;\nvar serverId = Random.id();\nvar startTime = new Date();\n\nKdData = new KdDataLayer({serverId: serverId});\n\nvar traceStore = new TraceStore({kdData: KdData});\ntraceStore.start();\n\n// Observers: KdConfig/listenersCount\nKdData.configColl.find({_id: 'listenersCount'}).observeChanges({\n  added: function(id, doc) {\n    SubHandlers.listeners.forEach(function(sub) {\n      sub.added('kdInfo', 'listeners-count', {count: doc.count});\n    });\n  },\n\n  changed: function(id, doc) {\n    SubHandlers.listeners.forEach(function(sub) {\n      sub.changed('kdInfo', 'listeners-count', {count: doc.count});\n    });\n  }\n});\n\n// Observers: KdTimeEvents/serverTimeEvents\nKdData.timeEventsColl.find({timestamp: {$gte: startTime}}).observeChanges({\n  added: function(docId, doc) {\n    if(doc && doc.data) {\n      var info = JSON.parse(doc.data);\n      var browserId = doc.browserId;\n      var clientId = doc.clientId;\n\n      SubHandlers.timeline.forEach(function(sub) {\n        var id = 'id' + ++uniqueId;\n        sub.added('kdTimeline', id, {\n          browserId: browserId,\n          clientId: clientId,\n          data: info\n        });\n        sub.removed('kdTimeline', id);\n      });\n    }\n  }\n});\n\n// publications\n\nMeteor.publish('kadira.debug.remote.auth', function(authKey) {\n  check(authKey, Match.Any);\n\n  // We need to check authentication of a production app only.\n  // For other development apps, we can use KD without any authentication\n  if(AppConfig.env === 'production') {\n    if(authKey !== AppConfig.authKey) {\n      throw new Meteor.Error('401', 'Unauthorized.');\n    }\n\n    // authorize remote session\n    var kadiraInfo = Kadira._getInfo();\n    var sessionId = kadiraInfo.session;\n\n    KdData.registerSession('remote', sessionId);\n  }\n\n  this.onStop(function() {\n    if(AppConfig.env === 'production') {\n      KdData.unregisterSession('remote', sessionId);\n    }\n  });\n\n  this.ready();\n});\n\nMeteor.publish('kadira.debug.remote.timeline', function() {\n  KadiraDebug._authorize('remote');\n\n  this.ready();\n\n  var sub = this;\n  SubHandlers.timeline.push(sub);\n\n  // increment listenersCount in DB\n  KdData.increaseListenersCount(1);\n\n  sub.onStop(function() {\n    var index = SubHandlers.timeline.indexOf(sub);\n    SubHandlers.timeline.splice(index, 1);\n\n    // decrement listenersCount in DB\n    KdData.increaseListenersCount(-1);\n  });\n});\n\nMeteor.publish('kadira.debug.client.auth', function(accessToken) {\n  check(accessToken, Match.Any);\n\n  // We need to check the accessToken in the production mode only.\n  // On development mode we don't need these checks.\n  if(AppConfig.env === 'production') {\n\n    if(!KdData.isValidToken(accessToken)) {\n      throw new Meteor.Error('401', 'Unauthorized.');\n    }\n\n    // authorize client session\n    var kadiraInfo = Kadira._getInfo();\n    var sessionId = kadiraInfo.session;\n\n    KdData.registerSession('client', sessionId);\n  }\n\n  this.onStop(function() {\n    if(AppConfig.env === 'production') {\n      KdData.unregisterSession('client', sessionId);\n    }\n  });\n\n  this.ready();\n});\n\nMeteor.publish('kadira.debug.client.listeners', function() {\n  KadiraDebug._authorize('client');\n\n  var sub = this;\n\n  var timelineCount = KdData.getListenersCount();\n\n  sub.added('kdInfo', 'listeners-count', {count: timelineCount});\n  sub.ready();\n\n  SubHandlers.listeners.push(sub);\n  sub.onStop(function() {\n    var index = SubHandlers.listeners.indexOf(sub);\n    SubHandlers.listeners.splice(index, 1);\n  });\n});\n\nMeteor.publish('kadira.debug.client.init', function(browserId, clientId) {\n  check(browserId, String);\n  check(clientId, String);\n\n  KadiraDebug._authorize('client');\n\n  var kadiraInfo = Kadira._getInfo();\n  if(kadiraInfo) {\n    var sessionId = kadiraInfo.session;\n\n    traceStore.registerSession(sessionId, browserId, clientId);\n\n    this.onStop(function() {\n      traceStore.unregisterSession(browserId, clientId);\n    });\n  }\n\n  this.ready();\n});\n\n// methods\nMeteor.methods({\n  'kadira.debug.client.updateTimeline': function(browserId, clientId, data) {\n    check(browserId, String);\n    check(clientId, String);\n    check(data, Object);\n\n    KadiraDebug._authorize('client');\n\n    // Pick tracked server time events and push them to the\n    // client's payload\n    // So, we can send them back to the server\n    var serverTimeEvents = traceStore.pickTimeEvents(browserId, clientId);\n    serverTimeEvents.forEach(function(ev) {\n      data.times.push(ev);\n    });\n\n    // set unique id for each server sessions\n    data.serverId = serverId;\n\n    var dataObj = {\n      browserId: browserId,\n      clientId: clientId,\n      type: 'timeEvents',\n      timestamp: new Date(),\n      data: JSON.stringify(data)\n    };\n\n    if(browserId && clientId) {\n      // update data to DB\n      KdData.setTimeEvent(dataObj);\n    }\n  },\n\n  'kadira.debug.client.getBrowserName': function(userAgent) {\n    check(userAgent, String);\n\n    KadiraDebug._authorize('client');\n\n    var parser = new UAParser(userAgent);\n    return parser.getResult().browser.name;\n  },\n\n  'kadira.debug.remote.getTrace': function(browserId, clientId, type, id) {\n    check(browserId, String);\n    check(clientId, String);\n    check(type, String);\n    check(id, String);\n\n    KadiraDebug._authorize('remote');\n\n    return traceStore.getTrace(browserId, clientId, type, id);\n  },\n\n  'kadira.debug.remote.getAppEnv': function() {\n    return AppConfig.env;\n  },\n\n  'kadira.debug.remote.createAccessToken': function() {\n    KadiraDebug._authorize('remote');\n\n    var token = Random.id(4);\n    KdData.registerAccessToken(token);\n\n    return token;\n  },\n\n  'kadira.debug.remote.reset': function() {\n    KadiraDebug._authorize('remote');\n\n    traceStore.reset();\n    KdData.reset();\n  }\n});\n\nKadiraDebug._authorize = function(type, sessionId) {\n  if(AppConfig.env === 'development') {\n    return true;\n  }\n\n  if(!sessionId) {\n    var kadiraInfo = Kadira._getInfo();\n    var sessionId = kadiraInfo.session;\n  }\n\n  if(KdData.isValidSession(type, sessionId)) {\n    return true;\n  } else {\n    throw new Meteor.Error('401', 'Unauthorized.');\n  }\n};\n"]}