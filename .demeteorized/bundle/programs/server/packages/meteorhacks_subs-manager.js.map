{"version":3,"sources":["meteor://ðŸ’»app/packages/meteorhacks_subs-manager/lib/sub_manager.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/packages/meteorhacks_subs-manager.js","sourcesContent":["var FastRender = null;\nif(Package['meteorhacks:fast-render']) {\n  FastRender = Package['meteorhacks:fast-render'].FastRender;\n}\n\nSubsManager = function (options) {\n  var self = this;\n  self.options = options || {};\n  // maxiumum number of subscriptions are cached\n  self.options.cacheLimit = self.options.cacheLimit || 10;\n  // maximum time, subscription stay in the cache\n  self.options.expireIn = self.options.expireIn || 5;\n\n  self._cacheMap = {};\n  self._cacheList = [];\n  self._ready = false;\n  self.dep = new Deps.Dependency();\n\n  self.computation = self._registerComputation();\n};\n\nSubsManager.prototype.subscribe = function() {\n  var self = this;\n  if(Meteor.isClient) {\n    var args = _.toArray(arguments);\n    this._addSub(args);\n\n    return {\n      ready: function() {\n        self.dep.depend();\n        return self._ready;\n      }\n    };\n  } else {\n    // to support fast-render\n    if(Meteor.subscribe) {\n      return Meteor.subscribe.apply(Meteor, arguments);\n    }\n  }\n};\n\nSubsManager.prototype._addSub = function(args) {\n  var self = this;\n  var hash = EJSON.stringify(args);\n  var subName = args[0];\n  var paramsKey = EJSON.stringify(args.slice(1));\n\n  if(!self._cacheMap[hash]) {\n    var sub = {\n      args: args,\n      hash: hash\n    };\n\n    this._handleError(sub);\n\n    self._cacheMap[hash] = sub;\n    self._cacheList.push(sub);\n\n    // if fast-render comes with this subscription\n    // we need to fake the ready message at first\n    // This is because we are delaying the actual subscription evaluation\n    // May be FastRender needs to send full list of subscription args to the client\n    // But, for now this is something working\n    if(FastRender && FastRender._subscriptions && FastRender._subscriptions[subName]) {\n      self._ready = self._ready && FastRender._subscriptions[subName][paramsKey];\n    } else {\n      self._ready = false;\n    }\n\n    // to notify the global ready()\n    self._notifyChanged();\n    \n    // no need to interfere with the current computation\n    self._reRunSubs();\n  }\n\n  // add the current sub to the top of the list\n  var sub = self._cacheMap[hash];\n  sub.updated = (new Date).getTime();\n\n  var index = _.indexOf(self._cacheList, sub);\n  self._cacheList.splice(index, 1);\n  self._cacheList.push(sub);\n};\n\nSubsManager.prototype._reRunSubs = function() {\n  var self = this;\n\n  if(Deps.currentComputation) {\n    Deps.afterFlush(function() {\n      self.computation.invalidate();\n    });\n  } else {\n    self.computation.invalidate();\n  }\n};\n\nSubsManager.prototype._notifyChanged = function() {\n  var self = this;\n  if(Deps.currentComputation) {\n    setTimeout(function() {\n      self.dep.changed();\n    }, 0);\n  } else {\n    self.dep.changed();\n  }\n};\n\nSubsManager.prototype._applyCacheLimit = function () {\n  var self = this;\n  var overflow = self._cacheList.length - self.options.cacheLimit;\n  if(overflow > 0) {\n    var removedSubs = self._cacheList.splice(0, overflow);\n    _.each(removedSubs, function(sub) {\n      delete self._cacheMap[sub.hash];\n    });\n  }\n};\n\nSubsManager.prototype._applyExpirations = function() {\n  var self = this;\n  var newCacheList = [];\n\n  var expirationTime = (new Date).getTime() - self.options.expireIn * 60 * 1000;\n  _.each(self._cacheList, function(sub) {\n    if(sub.updated >= expirationTime) {\n      newCacheList.push(sub);\n    } else {\n      delete self._cacheMap[sub.hash];\n    }\n  });\n\n  self._cacheList = newCacheList;\n};\n\nSubsManager.prototype._registerComputation = function() {\n  var self = this;\n  var computation = Deps.autorun(function() {\n    self._applyExpirations();\n    self._applyCacheLimit();\n\n    var ready = true;\n    _.each(self._cacheList, function(sub) {\n      sub.ready = Meteor.subscribe.apply(Meteor, sub.args).ready();\n      ready = ready && sub.ready;\n    });\n\n    if(ready) {\n      self._ready = true;\n      self._notifyChanged();\n    }\n  });\n\n  return computation;\n};\n\nSubsManager.prototype._createIdentifier = function(args) {\n  var tmpArgs = _.map(args, function(value) {\n    if(typeof value == \"string\") {\n      return '\"' + value + '\"';\n    } else {\n      return value;\n    }\n  });\n\n  return tmpArgs.join(', ');\n};\n\nSubsManager.prototype._handleError = function(sub) {\n  var args = sub.args;\n  var lastElement = _.last(args);\n  sub.identifier = this._createIdentifier(args);\n\n  if(!lastElement) {\n    args.push({onError: errorHandlingLogic});\n  } else if(typeof lastElement == \"function\") {\n    args.pop();\n    args.push({onReady: lastElement, onError: errorHandlingLogic});\n  } else if(typeof lastElement.onError == \"function\") {\n    var originalOnError = lastElement.onError;\n    lastElement.onError = function(err) {\n      errorHandlingLogic(err);\n      originalOnError(err);\n    };\n  } else if(typeof lastElement.onReady == \"function\") {\n    lastElement.onError = errorHandlingLogic;\n  } else {\n    args.push({onError: errorHandlingLogic});\n  }\n\n  function errorHandlingLogic (err) {\n    console.log(\"Error invoking SubsManager.subscribe(%s): \", sub.identifier , err.reason);\n    // expire this sub right away.\n    // Then expiration machanism will take care of the sub removal\n    sub.updated = new Date(1);\n  }\n};\n\nSubsManager.prototype.reset = function() {\n  var self = this;\n  var oldComputation = self.computation;\n  self.computation = self._registerComputation();\n\n  // invalidate the new compuation and it will fire new subscriptions\n  self.computation.invalidate();\n\n  // after above invalidation completed, fire stop the old computation\n  // which then send unsub messages\n  // mergeBox will correct send changed data and there'll be no flicker\n  Deps.afterFlush(function() {\n    oldComputation.stop();\n  });\n};\n\nSubsManager.prototype.clear = function() {\n  this._cacheList = [];\n  this._cacheMap = {};\n  this._reRunSubs();\n};\n\nSubsManager.prototype.ready = function() {\n  this.dep.depend();\n\n  // if there are no items in the cacheList we are not ready yet.\n  if(this._cacheList.length === 0) {\n    return false;\n  }\n  return this._ready;\n};\n"]}